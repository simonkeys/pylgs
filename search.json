[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pyLGS",
    "section": "",
    "text": "pyLGS performs simulations of the atomic physics of cw, modulated, and pulsed laser guide stars. The effects of the full atomic structure, atomic velocity distribution, one or multiple pump fields, the geomagnetic field, velocity-changing and spin-randomizing collisions, and atomic recoil are all taken into account.",
    "crumbs": [
      "pyLGS"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "pyLGS",
    "section": "Installation",
    "text": "Installation\npyLGS uses the CVODE library from the SUNDIALS package, with scikits.odes as the Python interface. Before installing pyLGS you may need to install SUNDIALS and the scikits.odes dependencies. On Ubuntu/Debian-based distributions this can be done with apt-get:\nsudo apt-get install python3-dev gcc gfortran libsundials-dev\n(Note that at least SUNDIALS version 6 is required – this is supplied by Ubuntu 24.04/Debian 12 and later.)\nOnce the above dependencies are installed, pyLGS can be installed with pip:\npip install pylgs",
    "crumbs": [
      "pyLGS"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "pyLGS",
    "section": "How to use",
    "text": "How to use\nImport the package:\n\nfrom pylgs.lgssystem import LGSSystem\n\nList available atomic systems for an LGS model:\n\nLGSSystem.builtins()\n\n['NaD1', 'Na330', 'NaD2', 'NaD2_Repump', 'NaD1_Toy']\n\n\nShow a level diagram for one of the atomic systems:\n\nLGSSystem.diagram(\"NaD2_Repump\", \"ToScale\")\n\n\n\n\n\n\n\n\nPrint some information about the system:\n\nLGSSystem.info(\"NaD2_Repump\")\n\n\nAtomic levels\n\\(\\text{3S}_{\\frac{1}{2}}\\), \\(\\text{3P}_{\\frac{3}{2}}\\)\n\n\nPump transitions\n\n\\(\\text{3S}_{\\frac{1}{2}}\\land F=1\\to \\text{3P}_{\\frac{3}{2}}\\)\n\\(\\text{3S}_{\\frac{1}{2}}\\land F=2\\to \\text{3P}_{\\frac{3}{2}}\\)\n\n\n\nTransition wavelengths\n\n\\(\\text{3P}_{\\frac{3}{2}}\\to \\text{3S}_{\\frac{1}{2}}\\): 589.158 nm\n\n\n\nSubstructure\n\nHyperfine structure included\nZeeman structure included\n24 total sublevels\n\n\n\nDensity matrix elements\n\nAll populations included\nAll Zeeman coherences (between same level and same F) included\nAll hyperfine coherences (between same level and different F) neglected\nOptical coherences (between different levels) included for pump transitions only\n374 total density matrix elements\n\n\n\nInput parameters\n\nBeamTransitRatePerS\nBFieldG\nMagneticAzimuthDegrees\nMagneticZenithDegrees\nRecoilParameter\nSDampingCollisionRatePerS\nTemperatureK\nVccRatePerS\nDetuningHz1\nDetuningHz2\nEllipticityDegrees1\nEllipticityDegrees2\nIntensitySI1\nIntensitySI2\nLaserWidthHz1\nLaserWidthHz2\nPolarizationAngleDegrees1\nPolarizationAngleDegrees2\n\n\n\n\nLoad the atomic system and set values for parameters that will not be varied:\n\nlgs = LGSSystem(\n    'NaD2_Repump', \n    {\n        'EllipticityDegrees1': 45.,\n        'PolarizationAngleDegrees1': 0,\n        'DetuningHz1': 1.0832e9,\n        'LaserWidthHz1': 10.0e6,\n        'EllipticityDegrees2': 45.,\n        'PolarizationAngleDegrees2': 0,\n        'DetuningHz2': -6.268e8 + 1.e8,\n        'LaserWidthHz2': 10.0e6,\n        'MagneticZenithDegrees': 45.,\n        'MagneticAzimuthDegrees': 45.,\n        'SDampingCollisionRatePerS': 4081.63,\n        'BeamTransitRatePerS': 131.944,\n        'VccRatePerS': 28571.,\n        'TemperatureK': 185.,\n        'RecoilParameter': 1\n    }\n)\n\nDefine sample values for the varying parameters:\n\nparams = {'IntensitySI1': 5., 'IntensitySI2': 46., 'BFieldG': 0.5}\n\nBuild a steady-state model with adaptively refined velocity groups based on the sample parameters:\n\nmodel = lgs.adaptive_stationary_model(params)\n\nSolve the model for the steady state using the sample parameters:\n\nsol = model.solve(params)\n\nFind the total return flux:\n\nmodel.total_flux(sol).item()\n\n7709.054844667825\n\n\nPlot the return flux as a function of atomic velocity:\n\nmodel.flux_distribution(sol).visualize()\n\n\n\n\n\n\n\n\nPlot the ground and excited state populations as a function of atomic velocity:\n\nmodel.level_population_distribution(sol).visualize()\n\n\n\n\n\n\n\n\nPlot the real and imaginary parts of all density-matrix elements:\n\nmodel.velocity_normalize(sol).visualize(line_width=1)",
    "crumbs": [
      "pyLGS"
    ]
  },
  {
    "objectID": "tutorials/technical_background.html",
    "href": "tutorials/technical_background.html",
    "title": "Technical background",
    "section": "",
    "text": "The state of an atomic ensemble is described by the density matrix \\(\\rho_{nm}\\), where the indices \\(n\\) and \\(m\\) represent attainable eigenstates of the atomic system. The Hamiltonian evolution of the density matrix is given by the Liouville–von Neumann equation \\[i\\hbar\\dot\\rho = [H,\\rho] \\tag{1}\\] with additional phenomenological terms added to the right-hand side to account for relaxation and repopulation processes resulting from external interactions.\nWriting the \\(N_\\rho\\) matrix elements of \\(\\rho\\) as a vector \\(\\rho_i\\) with a single index \\(i\\), the density-matrix evolution equation can be written as a linear matrix equation \\[\\dot\\rho_i = A_{ij}\\rho_j + b_i, \\tag{2}\\] where \\(\\rho\\), \\(A\\), and \\(b\\) may all depend on time. (Here and below we use Einstein summation notation, in which repeated indices are assumed to be summed over.)",
    "crumbs": [
      "Tutorials",
      "Technical background"
    ]
  },
  {
    "objectID": "tutorials/technical_background.html#the-liouville-von-neumann-equation",
    "href": "tutorials/technical_background.html#the-liouville-von-neumann-equation",
    "title": "Technical background",
    "section": "",
    "text": "The state of an atomic ensemble is described by the density matrix \\(\\rho_{nm}\\), where the indices \\(n\\) and \\(m\\) represent attainable eigenstates of the atomic system. The Hamiltonian evolution of the density matrix is given by the Liouville–von Neumann equation \\[i\\hbar\\dot\\rho = [H,\\rho] \\tag{1}\\] with additional phenomenological terms added to the right-hand side to account for relaxation and repopulation processes resulting from external interactions.\nWriting the \\(N_\\rho\\) matrix elements of \\(\\rho\\) as a vector \\(\\rho_i\\) with a single index \\(i\\), the density-matrix evolution equation can be written as a linear matrix equation \\[\\dot\\rho_i = A_{ij}\\rho_j + b_i, \\tag{2}\\] where \\(\\rho\\), \\(A\\), and \\(b\\) may all depend on time. (Here and below we use Einstein summation notation, in which repeated indices are assumed to be summed over.)",
    "crumbs": [
      "Tutorials",
      "Technical background"
    ]
  },
  {
    "objectID": "tutorials/technical_background.html#the-laser-guide-star-system",
    "href": "tutorials/technical_background.html#the-laser-guide-star-system",
    "title": "Technical background",
    "section": "The laser guide star system",
    "text": "The laser guide star system",
    "crumbs": [
      "Tutorials",
      "Technical background"
    ]
  },
  {
    "objectID": "tutorials/technical_background.html#velocity-dependence-and-discretization",
    "href": "tutorials/technical_background.html#velocity-dependence-and-discretization",
    "title": "Technical background",
    "section": "Velocity dependence and discretization",
    "text": "Velocity dependence and discretization\nBecause of the Doppler shift for atoms with nonzero velocity along the direction of the laser beam, it is important to distinguish between atoms with different longitudinal velocities – \\(\\rho(v)\\), \\(A(v)\\), and \\(b(v)\\) are all functions of longitudinal velocity \\(v\\). The constant term \\(b(v)\\) describes the effect of transit repopulation, while the \\(A(v)\\) includes the effect of several physical processes, of which Doppler shift, velocity-changing collisions (vcc), and recoil depend on velocity, each in a different manner.\nThe Doppler shift of the pump light is proportional to \\(v\\), so the term describing the Doppler shift can be written \\[\\dot\\rho_i(v)|_\\text{dop}=vA^\\text{dop}_{ij}\\rho_j(v).\\] Velocity-changing collisions (vcc) are assumed to change the velocity of an atom to any other velocity with probability given by the Maxwell-Boltzmann distribution \\(n(v)\\), so this term is proportional to \\(n(v)\\) and is multiplied by the integral of \\(\\rho\\) over all velocities, \\(\\int\\rho_j(v')dv'\\): \\[\\dot\\rho_i(v)|_\\text{vcc}=A^\\text{vcc}_{ij}n(v)\\int\\rho_j(v')dv'.\\] Atoms undergoing recoil have their velocities increased, transferring them to a neighboring velocity group, so this term is proportional to the derivative of \\(\\rho(v)\\): \\[\\dot\\rho_i(v)|_\\text{rec}=A^\\text{rec}_{ij}\\frac{d\\rho_j}{dv}.\\] Atoms entering the illuminated region have the Maxwell-Boltzmann velocity distribution, so this term is proportional to \\(n(v)\\): \\[\\dot\\rho_i(v)|_\\text{trans}=n(v)b_i.\\] Finally, there is also a term that is independent of the atomic velocity: \\[\\dot\\rho_i(v)|_\\text{ind}=A^\\text{ind}_{ij}\\rho_j(v).\\]\nCorresponding equations for the density matrices \\(\\rho_{vi}\\) for a discretized velocity distribution with \\(N_v\\) velocity bins can be obtained by integrating the terms over each bin with mean velocities \\(v\\), widths \\(\\Delta v\\), and fractional densities \\(n_v\\Delta v\\). This results in the terms \\[\\dot\\rho_{vi}|_\\text{dop}=vA^\\text{dop}_{ij}\\rho_{vj}=(v\\delta_{vv'})A^\\text{dop}_{ij}\\rho_{v'j}, \\] \\[\\dot\\rho_{vi}|_\\text{vcc}=A^\\text{vcc}_{ij}n_v\\sum_{v'}\\rho_{v'j}=(n_v1_{v'})A^\\text{vcc}_{ij}\\rho_{v'j},\\] \\[\\dot\\rho_{vi}|_\\text{rec}=A^\\text{rec}_{ij}\\frac{\\rho_{v+1,j}-\\rho_{vj}}{\\Delta v}=\\frac{\\delta_{v+1,v'}-\\delta_{vv'}}{\\Delta v}A^\\text{rec}_{ij}\\rho_{v'j},\\] \\[\\dot\\rho_{vi}|_\\text{trans}=n_vb_i,\\] \\[\\dot\\rho_{vi}|_\\text{ind}=A^\\text{ind}_{ij}\\rho_{vj}=\\delta_{vv'}A^\\text{ind}_{ij}\\rho_{v'j},\\] where we have inserted operators on velocity space (\\(\\delta_{vv'}\\) is the Kronecker delta function, i.e., identity matrix, and \\(1_{v'}\\) is 1 for all values of \\(v'\\)) to make it explicit that we now have a linear equation for the \\((N_v\\times N_\\rho)\\) matrix \\(\\rho_{vi}\\) in terms of four-dimensional \\((N_v\\times N_v \\times N_\\rho\\times N_\\rho)\\) matrices. The combined equation now reads \\[\n    \\dot\\rho_{vi}\n        = \\left[\n            \\delta_{vv'}A^\\text{ind}_{ij}\n            + (v\\delta_{vv'})A^\\text{dop}_{ij}\n            + (n_v1_{v'})A^\\text{vcc}_{ij}\n            + \\frac{\\delta_{v+1,v'}-\\delta_{vv'}}{\\Delta v}A^\\text{rec}_{ij}\n        \\right]\\rho_{v'j}\n        + n_vb_i.\n\\tag{3}\\]",
    "crumbs": [
      "Tutorials",
      "Technical background"
    ]
  },
  {
    "objectID": "tutorials/technical_background.html#representation-in-the-pymor-framework",
    "href": "tutorials/technical_background.html#representation-in-the-pymor-framework",
    "title": "Technical background",
    "section": "Representation in the pyMOR framework",
    "text": "Representation in the pyMOR framework\nIn the pyMOR framework, vectors of independent variables such as \\(\\rho_{vi}\\) are represented by VectorArray objects, and the matrices that connect them are represented by Operator objects. The pyLGS LGSSystem object can generate the objects corresponding to the terms in Equation 3.\nImport the package:\n\nfrom pylgs.lgssystem import LGSSystem\nfrom pylgs.velocitygroups import VelocityGroups\nfrom pymor.algorithms.simplify import contract\nfrom pymor.algorithms.to_matrix import to_matrix\nimport numpy as np\n\nSet numpy print options:\n\nnp.set_printoptions(formatter={'float': lambda x: f'{x:^ 8.2}' if x else f'{0:^ 8}'}, linewidth=140)\n\nFor simplicity, select a toy LGS atomic system with no angular momentum and fix all parameters:\n\nlgs = LGSSystem(\n    'NaD1_Toy',\n    fixed_params={'IntensitySI1': 46.,\n                  'EllipticityDegrees1': 45.0,\n                  'PolarizationAngleDegrees1': 0,\n                  'DetuningHz1': -6.268e8,\n                  'LaserWidthHz1': 10.0e6,\n                  'BFieldG': 0.5,\n                  'MagneticZenithDegrees': 45.0,\n                  'MagneticAzimuthDegrees': 45.0,\n                  'SDampingCollisionRatePerS': 4081.63,\n                  'BeamTransitRatePerS': 131.944,\n                  'VccRatePerS': 28571.42,\n                  'TemperatureK': 185.0,\n                  'RecoilParameter': 1,\n                 }\n)\n\nThe \\(A^\\text{ind}_{ij}\\) operator is given by lgs.A_ind:\n\nlgs.A_ind\n\nA_ind{DM(4)} → {DM(4)}\n\n\nThe toy atomic system has only two states and four density-matrix elements, so \\(A^\\text{ind}_{ij}\\) is a \\(4\\times4\\) matrix. We can see it explicitly using to_numpy():\n\nlgs.A_ind.to_numpy()\n\narray([[-2.9e+04,     0   ,  2.6e+07,  6.1e+07],\n       [    0   , -6.2e+07, -3.9e+09,     0   ],\n       [-1.3e+07,  3.9e+09, -6.2e+07,  1.3e+07],\n       [    0   ,     0   , -2.6e+07, -6.1e+07]])\n\n\nWe can similarly view \\(A^\\text{dop}_{ij}\\):\n\nlgs.A_dop.to_numpy()\n\narray([[    0   ,     0   ,     0   ,     0   ],\n       [    0   ,     0   , -3.9e+09,     0   ],\n       [    0   ,  3.9e+09,     0   ,     0   ],\n       [    0   ,     0   ,     0   ,     0   ]])\n\n\n\\(A^\\text{vcc}_{ij}\\):\n\nlgs.A_vcc.to_numpy()\n\narray([[ 2.9e+04,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,     0   ,  2.9e+04]])\n\n\n\\(A^\\text{rec}_{ij}\\):\n\nlgs.A_rec.to_numpy()\n\narray([[    0   ,     0   ,     0   , -4.9e+03],\n       [    0   ,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,     0   ,     0   ]])\n\n\nAnd \\(b_{i}\\):\n\nlgs.b.to_numpy()\n\narray([[ 1.3e+02],\n       [    0   ],\n       [    0   ],\n       [    0   ]])\n\n\nTo form the velocity-space operators from Equation 3, we first define a set of velocity groups, here three evenly spaced groups:\n\nvg = VelocityGroups(3)\n\nThe explicit form of \\(\\delta_{vv'}\\) is\n\nvg.identity().to_numpy()\n\narray([[   1.0  ,     0   ,     0   ],\n       [    0   ,    1.0  ,     0   ],\n       [    0   ,     0   ,    1.0  ]])\n\n\n\\(v\\delta_{vv'}\\):\n\nvg.velocity_diagonal().to_numpy()\n\narray([[  -2.0  ,     0   ,     0   ],\n       [    0   ,     0   ,     0   ],\n       [    0   ,     0   ,    2.0  ]])\n\n\n\\(n_v1_{v'}\\):\n\nvg.n_times_1().to_numpy()\n\narray([[  0.079 ,   0.079 ,   0.079 ],\n       [  0.84  ,   0.84  ,   0.84  ],\n       [  0.079 ,   0.079 ,   0.079 ]])\n\n\nAnd \\((\\delta_{v+1,v'}-\\delta_{vv'})/\\Delta v\\):\n\nvg.drho_dv().to_numpy()\n\narray([[   0.5  ,     0   ,     0   ],\n       [  -0.5  ,    0.5  ,     0   ],\n       [    0   ,   -0.5  ,    0.5  ]])\n\n\nThe combined operator \\(A\\), including both density-matrix and velocity-group factors, can be constructed with\n\nA = contract(lgs.operator(vg))\nA\n\nX{AV(3) ⨉ DM(4)} → {AV(3) ⨉ DM(4)}\n\n\nInternally, it is represented by a 4-dimensional xarray DataArray:\n\nA.matrix\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (Atomic velocity (range): 3, Atomic velocity: 3,\n                   Density matrix (range): 4, Density matrix (source): 4)&gt; Size: 2kB\n&lt;COO: shape=(3, 3, 4, 4), dtype=float64, nnz=47, fill_value=-0.0&gt;\nCoordinates:\n  * Atomic velocity (range)  (Atomic velocity (range)) float64 24B -2.0 0.0 2.0\n  * Atomic velocity          (Atomic velocity) float64 24B -2.0 0.0 2.0\n  * Density matrix (range)   (Density matrix (range)) &lt;U50 800B 'ρ&lt;sub&gt;Re, 3S...\n  * Density matrix (source)  (Density matrix (source)) &lt;U50 800B 'ρ&lt;sub&gt;Re, 3...xarray.DataArrayAtomic velocity (range): 3Atomic velocity: 3Density matrix (range): 4Density matrix (source): 4&lt;COO: nnz=47, fill_value=-0.0&gt;\n\n\n\nFormat\ncoo\n\n\nData Type\nfloat64\n\n\nShape\n(3, 3, 4, 4)\n\n\nnnz\n47\n\n\nDensity\n0.3263888888888889\n\n\nRead-only\nTrue\n\n\nSize\n1.8K\n\n\nStorage ratio\n1.63\n\n\n\nCoordinates: (4)Atomic velocity (range)(Atomic velocity (range))float64-2.0 0.0 2.0array([-2.,  0.,  2.])Atomic velocity(Atomic velocity)float64-2.0 0.0 2.0array([-2.,  0.,  2.])Density matrix (range)(Density matrix (range))&lt;U50'ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3S&lt;...array(['ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3S&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3P&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;'], dtype='&lt;U50')Density matrix (source)(Density matrix (source))&lt;U50'ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3S&lt;...array(['ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3S&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3P&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;'], dtype='&lt;U50')Indexes: (4)Atomic velocity (range)PandasIndexPandasIndex(Index([-2.0, 0.0, 2.0], dtype='float64', name='Atomic velocity (range)'))Atomic velocityPandasIndexPandasIndex(Index([-2.0, 0.0, 2.0], dtype='float64', name='Atomic velocity'))Density matrix (range)PandasIndexPandasIndex(Index(['ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3S&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3P&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;'],\n      dtype='object', name='Density matrix (range)'))Density matrix (source)PandasIndexPandasIndex(Index(['ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3S&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3P&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;'],\n      dtype='object', name='Density matrix (source)'))Attributes: (0)\n\n\nWe can also express it as a \\(12\\times12\\) block matrix with the \\(4\\times4\\) elements of each block referring to density-matrix elements, and each of the \\(3\\times3\\) array of blocks referring to a pair of velocity groups:\n\nto_matrix(A).toarray()\n\narray([[ 2.6e+04,     0   , -2.6e+07, -6.1e+07, -2.2e+03,     0   ,     0   ,     0   , -2.2e+03,     0   ,     0   ,     0   ],\n       [    0   ,  6.2e+07, -3.9e+09,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ],\n       [ 1.3e+07,  3.9e+09,  6.2e+07, -1.3e+07,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,  2.6e+07,  6.1e+07,     0   ,     0   ,     0   , -2.2e+03,     0   ,     0   ,     0   , -2.2e+03],\n       [-2.4e+04,     0   ,     0   , -2.5e+03,  4.6e+03,     0   , -2.6e+07, -6.1e+07, -2.4e+04,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,     0   ,     0   ,     0   ,  6.2e+07,  3.9e+09,     0   ,     0   ,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,     0   ,     0   ,  1.3e+07, -3.9e+09,  6.2e+07, -1.3e+07,     0   ,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,     0   , -2.4e+04,     0   ,     0   ,  2.6e+07,  6.1e+07,     0   ,     0   ,     0   , -2.4e+04],\n       [-2.2e+03,     0   ,     0   ,     0   , -2.2e+03,     0   ,     0   , -2.5e+03,  2.6e+04,     0   , -2.6e+07, -6.1e+07],\n       [    0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,  6.2e+07,  1.2e+10,     0   ],\n       [    0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,     0   ,  1.3e+07, -1.2e+10,  6.2e+07, -1.3e+07],\n       [    0   ,     0   ,     0   , -2.2e+03,     0   ,     0   ,     0   , -2.2e+03,     0   ,     0   ,  2.6e+07,  6.1e+07]])\n\n\nThe expanded form is used when the solver needs an explicit form of the matrix for sparse ILU factorization.",
    "crumbs": [
      "Tutorials",
      "Technical background"
    ]
  },
  {
    "objectID": "tutorials/technical_background.html#solving-the-stationary-model",
    "href": "tutorials/technical_background.html#solving-the-stationary-model",
    "title": "Technical background",
    "section": "Solving the stationary model",
    "text": "Solving the stationary model",
    "crumbs": [
      "Tutorials",
      "Technical background"
    ]
  },
  {
    "objectID": "tutorials/technical_background.html#solving-the-instationary-model",
    "href": "tutorials/technical_background.html#solving-the-instationary-model",
    "title": "Technical background",
    "section": "Solving the instationary model",
    "text": "Solving the instationary model",
    "crumbs": [
      "Tutorials",
      "Technical background"
    ]
  },
  {
    "objectID": "tutorials/technical_background.html#solving-the-floquet-model",
    "href": "tutorials/technical_background.html#solving-the-floquet-model",
    "title": "Technical background",
    "section": "Solving the Floquet model",
    "text": "Solving the Floquet model",
    "crumbs": [
      "Tutorials",
      "Technical background"
    ]
  },
  {
    "objectID": "tutorials/sodium_lgs.html",
    "href": "tutorials/sodium_lgs.html",
    "title": "Sodium LGS",
    "section": "",
    "text": "Import the LGSSystem class from the pylgs module:\nfrom pylgs.lgssystem import LGSSystem\nimport numpy as np\nimport pymor\nDefine an LGS system on the D\\(_2\\) line with pump and repump beams, with all parameters fixed except for the light intensities and the magnetic-field strength:\nlgs = LGSSystem(\n    'NaD2_Repump', \n    {\n        'EllipticityDegrees1': 45.,\n        'PolarizationAngleDegrees1': 0,\n        'DetuningHz1': 1.0832e9,\n        'LaserWidthHz1': 10.0e6,\n        'EllipticityDegrees2': 45.,\n        'PolarizationAngleDegrees2': 0,\n        'DetuningHz2': -6.268e8,\n        'LaserWidthHz2': 10.0e6,\n        'MagneticZenithDegrees': 45.,\n        'MagneticAzimuthDegrees': 45.,\n        'SDampingCollisionRatePerS': 4081.63,\n        'BeamTransitRatePerS': 131.944,\n        'VccRatePerS': 28571.,\n        'TemperatureK': 185.,\n        'RecoilParameter': 1\n    }\n)\nThe model contains equations for 374 density-matrix elements:\nlgs.A_ind.range\n\n{Density matrix (range)(374)}\nDefine sample values for the variable parameters:\nparams = {'IntensitySI1': 5., 'IntensitySI2': 46., 'BFieldG': 0.5}",
    "crumbs": [
      "Tutorials",
      "Sodium LGS"
    ]
  },
  {
    "objectID": "tutorials/sodium_lgs.html#steady-state-of-a-cw-lgs",
    "href": "tutorials/sodium_lgs.html#steady-state-of-a-cw-lgs",
    "title": "Sodium LGS",
    "section": "Steady state of a cw LGS",
    "text": "Steady state of a cw LGS\n\nEvenly spaced velocity groups\nBuild a model for the steady state of a cw LGS with 200 evenly spaced velocity groups:\n\nmodel = lgs.stationary_model(vg=200)\n\nFind the steady-state return flux:\n\nmodel.total_flux(params).item()\n\n13625.270307926916\n\n\nFind the density matrix for each of the 200 velocity groups:\n\nsol = model.solve(params)\nsol\n\n{Atomic velocity(200) ⨉ Density matrix (source)(374), }\n\n\nThe result is expressed as an XarrayVectorArray object representing 200 vectors each of size 374. The XarrayVectorArray is a wrapper for an xarray DataArray, which can be accessed via the XarrayVectorArray.array attribute:\n\nsol.array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (Atomic velocity: 200, Density matrix (source): 374)&gt; Size: 598kB\narray([[ 4.39820989e-07,  1.36790153e-07, -1.36692297e-07, ...,\n         4.11349076e-11,  2.15032837e-13,  3.90993999e-14],\n       [ 5.25623820e-07,  1.63475922e-07, -1.63358570e-07, ...,\n         4.96457650e-11,  2.62098981e-13,  4.73161225e-14],\n       [ 6.27016980e-07,  1.95009270e-07, -1.94868909e-07, ...,\n         5.98154463e-11,  3.18954046e-13,  5.71688740e-14],\n       ...,\n       [ 6.25164298e-07,  1.95204690e-07, -1.95037857e-07, ...,\n        -6.26906845e-11,  3.50162745e-13,  6.07662656e-14],\n       [ 5.24087271e-07,  1.63638177e-07, -1.63498877e-07, ...,\n        -5.20072904e-11,  2.87471533e-13,  5.02408015e-14],\n       [ 4.38562256e-07,  1.36929700e-07, -1.36813585e-07, ...,\n        -4.30715543e-11,  2.35630633e-13,  4.14736854e-14]])\nCoordinates:\n  * Atomic velocity          (Atomic velocity) float64 2kB -2.985 ... 2.985\n  * Density matrix (source)  (Density matrix (source)) &lt;U68 102kB 'ρ&lt;sub&gt;Re, ...xarray.DataArrayAtomic velocity: 200Density matrix (source): 3744.398e-07 1.368e-07 -1.367e-07 ... -4.307e-11 2.356e-13 4.147e-14array([[ 4.39820989e-07,  1.36790153e-07, -1.36692297e-07, ...,\n         4.11349076e-11,  2.15032837e-13,  3.90993999e-14],\n       [ 5.25623820e-07,  1.63475922e-07, -1.63358570e-07, ...,\n         4.96457650e-11,  2.62098981e-13,  4.73161225e-14],\n       [ 6.27016980e-07,  1.95009270e-07, -1.94868909e-07, ...,\n         5.98154463e-11,  3.18954046e-13,  5.71688740e-14],\n       ...,\n       [ 6.25164298e-07,  1.95204690e-07, -1.95037857e-07, ...,\n        -6.26906845e-11,  3.50162745e-13,  6.07662656e-14],\n       [ 5.24087271e-07,  1.63638177e-07, -1.63498877e-07, ...,\n        -5.20072904e-11,  2.87471533e-13,  5.02408015e-14],\n       [ 4.38562256e-07,  1.36929700e-07, -1.36813585e-07, ...,\n        -4.30715543e-11,  2.35630633e-13,  4.14736854e-14]])Coordinates: (2)Atomic velocity(Atomic velocity)float64-2.985 -2.955 ... 2.955 2.985array([-2.985, -2.955, -2.925, -2.895, -2.865, -2.835, -2.805, -2.775, -2.745,\n       -2.715, -2.685, -2.655, -2.625, -2.595, -2.565, -2.535, -2.505, -2.475,\n       -2.445, -2.415, -2.385, -2.355, -2.325, -2.295, -2.265, -2.235, -2.205,\n       -2.175, -2.145, -2.115, -2.085, -2.055, -2.025, -1.995, -1.965, -1.935,\n       -1.905, -1.875, -1.845, -1.815, -1.785, -1.755, -1.725, -1.695, -1.665,\n       -1.635, -1.605, -1.575, -1.545, -1.515, -1.485, -1.455, -1.425, -1.395,\n       -1.365, -1.335, -1.305, -1.275, -1.245, -1.215, -1.185, -1.155, -1.125,\n       -1.095, -1.065, -1.035, -1.005, -0.975, -0.945, -0.915, -0.885, -0.855,\n       -0.825, -0.795, -0.765, -0.735, -0.705, -0.675, -0.645, -0.615, -0.585,\n       -0.555, -0.525, -0.495, -0.465, -0.435, -0.405, -0.375, -0.345, -0.315,\n       -0.285, -0.255, -0.225, -0.195, -0.165, -0.135, -0.105, -0.075, -0.045,\n       -0.015,  0.015,  0.045,  0.075,  0.105,  0.135,  0.165,  0.195,  0.225,\n        0.255,  0.285,  0.315,  0.345,  0.375,  0.405,  0.435,  0.465,  0.495,\n        0.525,  0.555,  0.585,  0.615,  0.645,  0.675,  0.705,  0.735,  0.765,\n        0.795,  0.825,  0.855,  0.885,  0.915,  0.945,  0.975,  1.005,  1.035,\n        1.065,  1.095,  1.125,  1.155,  1.185,  1.215,  1.245,  1.275,  1.305,\n        1.335,  1.365,  1.395,  1.425,  1.455,  1.485,  1.515,  1.545,  1.575,\n        1.605,  1.635,  1.665,  1.695,  1.725,  1.755,  1.785,  1.815,  1.845,\n        1.875,  1.905,  1.935,  1.965,  1.995,  2.025,  2.055,  2.085,  2.115,\n        2.145,  2.175,  2.205,  2.235,  2.265,  2.295,  2.325,  2.355,  2.385,\n        2.415,  2.445,  2.475,  2.505,  2.535,  2.565,  2.595,  2.625,  2.655,\n        2.685,  2.715,  2.745,  2.775,  2.805,  2.835,  2.865,  2.895,  2.925,\n        2.955,  2.985])Density matrix (source)(Density matrix (source))&lt;U68'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2,...array(['ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 1)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 1)&lt;/sub&gt;',\n       ...,\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 1, -1), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 1, -1), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;'],\n      dtype='&lt;U68')Indexes: (2)Atomic velocityPandasIndexPandasIndex(Index([-2.9850000000000003,              -2.955,              -2.925,\n                    -2.895,              -2.865,              -2.835,\n       -2.8049999999999997,              -2.775,              -2.745,\n                    -2.715,\n       ...\n                     2.715,  2.7449999999999997,               2.775,\n        2.8049999999999997,  2.8349999999999995,  2.8649999999999998,\n                     2.895,               2.925,  2.9549999999999996,\n                     2.985],\n      dtype='float64', name='Atomic velocity', length=200))Density matrix (source)PandasIndexPandasIndex(Index(['ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 1)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 1)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 1), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 1)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 1), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 1), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 0), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, 2), (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, -1)&lt;/sub&gt;',\n       ...\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, -1), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, -2), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 2, -2), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 1, 1), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 1, 1), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 1, 0), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 1, 0), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 1, -1), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, (3S&lt;sub&gt;1/2&lt;/sub&gt;, 1, -1), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0), (3P&lt;sub&gt;3/2&lt;/sub&gt;, 0, 0)&lt;/sub&gt;'],\n      dtype='object', name='Density matrix (source)', length=374))Attributes: (0)\n\n\nUse the density-matrix solution to find the velocity distribution of flux as an XarrayVectorArray:\n\nflux = model.flux_distribution(sol)\nflux\n\n{Atomic velocity(200) ⨉ Transition(1), }\n\n\nXarrayVectorArray objects have built-in visualization routines. Plot the velocity distribution of return flux:\n\nmodel.flux_distribution(sol).visualize(xaxis_range=(-.5, .5))\n\n                                                \n\n\nPlot the level population distribution:\n\nmodel.level_population_distribution(sol).visualize()\n\n                                                \n\n\n\n\nAdaptive refinement of velocity groups\nBuild a steady-state model with each velocity group contributing no more than 2% of the return flux:\n\nmodel = lgs.adaptive_stationary_model(params, max_weight=0.02)\n\nFind the total flux for this model:\n\nmodel.total_flux(params).item()\n\n13521.856397884763\n\n\nFind the density matrix. In this case the adaptive refinement has produced 82 velocity groups:\n\nsol = model.solve(params)\nsol\n\n{Atomic velocity(82) ⨉ Density matrix (source)(374), }\n\n\nThe flux distribution shows that this is a more detailed description of the system than the model with a greater number of evenly spaced velocity groups:\n\nmodel.flux_distribution(sol).visualize(xaxis_range=(-.5, .5))\n\n                                                \n\n\n\n\nDependence on system parameters\nFind the steady-state density matrix for 10 different values of repump intensity, with the total pump + repump intensity held constant:\n\nsol = model.solve([\n    {'BFieldG': .5},\n    {\n        'IntensitySI1': np.linspace(0, 25, 10), \n        'IntensitySI2': 50 - np.linspace(0, 25, 10)\n    }\n])\nsol\n\n\n\n\n{Atomic velocity(82) ⨉ Density matrix (source)(374), IntensitySI1(10)}\n\n\nPlot the total flux to show the optimal value of repump intensity for these conditions:\n\nmodel.total_flux(sol).visualize()\n\n                                                \n\n\nCreate an animation of the flux distribution as the repump intensity is varied:\n\nmodel.flux_distribution(sol).visualize(xaxis_range=(-.5, .5))\n\n                                                \n\n\nAnimate the level population distribution as a function of repump intensity:\n\nmodel.level_population_distribution(sol).visualize()",
    "crumbs": [
      "Tutorials",
      "Sodium LGS"
    ]
  },
  {
    "objectID": "tutorials/sodium_lgs.html#transient-dynamics",
    "href": "tutorials/sodium_lgs.html#transient-dynamics",
    "title": "Sodium LGS",
    "section": "Transient dynamics",
    "text": "Transient dynamics\n\nTransient dynamics from a laser pulse\nBuild a dynamical model (InstationaryModel) using the velocity groups from the adaptively refined steady-state model:\n\nmodel = lgs.instationary_model(\n    vg=model.data['velocity_groups'], \n    T=1e-5, \n    num_values=100\n)\n\nSet tolerances for the BDF solver:\n\npymor.basic.set_defaults({\n    'pylgs.pymor.timestepping.cvode_solver_options.cvode_bdf_atol': 1e-6,\n    'pylgs.pymor.timestepping.cvode_solver_options.cvode_bdf_rtol': 1e-4,\n})\n\nSolve for the density-matrix evolution. The solution contains the density matrix for each velocity group at 100 time values:\n\nsol = model.solve(params)\nsol\n\n\n\n\n{Atomic velocity(82) ⨉ Density matrix (source)(374), Time(100)}\n\n\nPlot the total flux as a function of time:\n\nmodel.total_flux(sol).visualize()\n\n                                                \n\n\nAnimate the flux distribution as a function of time:\n\nmodel.flux_distribution(sol).visualize()\n\n                                                \n\n\nAnimate the level population distribution:\n\nmodel.level_population_distribution(sol).visualize(xaxis_range=(-1, 1))\n\n                                                \n\n\n\n\nTransient dynamics with modulated laser intensity\nSolve the InstationaryModel with sinusoidally modulated light intensity:\n\nsol = model.solve({\n    'IntensitySI1': \"5.*sin(1e6*t)**2\", \n    'IntensitySI2': \"46.*sin(1e6*t)**2\",\n    'BFieldG': .5\n})\n\nThe total flux as a function of time:\n\nmodel.total_flux(sol).visualize()\n\n                                                \n\n\nThe animated flux distribution:\n\nmodel.flux_distribution(sol).visualize(xaxis_range=(-.25, .25))\n\n                                                \n\n\nThe animated level population distribution:\n\nmodel.level_population_distribution(sol).visualize(xaxis_range=(-.25, .25))",
    "crumbs": [
      "Tutorials",
      "Sodium LGS"
    ]
  },
  {
    "objectID": "tutorials/sodium_lgs.html#periodic-state-of-a-modulated-system",
    "href": "tutorials/sodium_lgs.html#periodic-state-of-a-modulated-system",
    "title": "Sodium LGS",
    "section": "Periodic state of a modulated system",
    "text": "Periodic state of a modulated system\nThe StationaryFloquetModel solves for the periodic state of a modulated system after the transient dynamics have died out.\nBuild a stationary Floquet model for six Fourier harmonics of a system with sinusoidally modulated intensity:\n\nmodel = lgs.stationary_floquet_model(\n    {\n        'IntensitySI1': \"5.*sin(nu*t)**2\", \n        'IntensitySI2': \"46.*sin(nu*t)**2\"\n    },\n    T=np.linspace(0, 1e-5, 100),\n    n_vector=6,\n    vg=model.data['velocity_groups']\n)\n\nDefine values for the modulation frequency and magnetic field:\n\nmu = {'nu': 1e6, 'BFieldG': .5}\n\nSolve for the periodic state. The solution contains 13 Fourier coefficients for each density-matrix element in each velocity group:\n\nsol = model.solve(mu)\nsol\n\n{Fourier coefficient(13) ⨉ Atomic velocity(82) ⨉ Density matrix (source)(374), }\n\n\nThe real and imaginary parts of the Fourier coefficients of the time-dependent return flux:\n\nmodel.total_flux(sol).visualize()\n\n                                                \n\n\nThe total return flux reconstructed as a function of time:\n\nmodel.reconstructed_total_flux(sol, mu).real.visualize()\n\n                                                \n\n\nThe level population distribution as a function of time:\n\nmodel.level_population_distribution(model.reconstruct(sol, mu)).real.visualize()",
    "crumbs": [
      "Tutorials",
      "Sodium LGS"
    ]
  },
  {
    "objectID": "api/pymor/vectorarrays.html#xarrayvectorspace",
    "href": "api/pymor/vectorarrays.html#xarrayvectorspace",
    "title": "pymor.vectorarrays",
    "section": "XarrayVectorSpace",
    "text": "XarrayVectorSpace\n\nsource\n\nXarrayVectorSpace\n\n XarrayVectorSpace (coords:Union[xarray.core.coordinates.Coordinates,dict,\n                    xarray.core.dataarray.DataArray,NoneType]=None,\n                    name:Optional[str]=None, attrs:Optional[dict]=None,\n                    id=None)\n\nVectorSpace of XarrayVectorArrays.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoords\nUnion\nNone\n\n\n\nname\nOptional\nNone\n\n\n\nattrs\nOptional\nNone\n\n\n\nid\nNoneType\nNone\nSee ~pymor.vectorarrays.interface.VectorSpace.id.\n\n\n\n“Empty” XarrayVectorSpace with no coordinates (used, for example, for operators whose range is a scalar):\n\nXarrayVectorSpace()\n\n{1}\n\n\nXarrayVectorSpace from dictionary of coordinates:\n\ncoords = {'foo': [1, 2, 3], 'bar': ['a', 'b']}\nXarrayVectorSpace(coords)\n\n{foo(3) ⨉ bar(2)}\n\n\nFrom xarray Coordinates:\n\ncoords = Coordinates(coords)\nXarrayVectorSpace(coords)\n\n{foo(3) ⨉ bar(2)}\n\n\nFrom DataArray with default dimensions and coordinates:\n\nda = DataArray(np.ones(coords.shape))\nXarrayVectorSpace(da)\n\n{dim_0(3) ⨉ dim_1(2)}\n\n\nFrom DataArray:\n\nda = DataArray(np.ones(coords.shape), coords=coords, name='baz')\nspace = XarrayVectorSpace(da)\nspace\n\n{foo(3) ⨉ bar(2)}\n\n\n\nsource\n\n\nXarrayVectorSpace.zeros\n\n XarrayVectorSpace.zeros (coords:Optional[dict]=None)\n\nReturn XarrayVectorArray of null vectors in XarrayVectorSpace optionally extended to include supplied coordinates coords.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoords\nOptional\nNone\nCoordinates to extend vector space over\n\n\nReturns\nXarrayVectorArray\n\nXarrayVectorArray with all elements equal to zero\n\n\n\n\nU = space.zeros()\nU\n\n{foo(3) ⨉ bar(2), }\n\n\n\nU.array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'baz' (foo: 3, bar: 2)&gt; Size: 48B\narray([[0., 0.],\n       [0., 0.],\n       [0., 0.]])\nCoordinates:\n  * foo      (foo) int64 24B 1 2 3\n  * bar      (bar) &lt;U1 8B 'a' 'b'xarray.DataArray'baz'foo: 3bar: 20.0 0.0 0.0 0.0 0.0 0.0array([[0., 0.],\n       [0., 0.],\n       [0., 0.]])Coordinates: (2)foo(foo)int641 2 3array([1, 2, 3])bar(bar)&lt;U1'a' 'b'array(['a', 'b'], dtype='&lt;U1')Indexes: (2)fooPandasIndexPandasIndex(Index([1, 2, 3], dtype='int64', name='foo'))barPandasIndexPandasIndex(Index(['a', 'b'], dtype='object', name='bar'))Attributes: (0)\n\n\n\nspace.zeros({'bam': [.2, .3, .4]})\n\n{foo(3) ⨉ bar(2), bam(3)}\n\n\n\nsource\n\n\nXarrayVectorSpace.ones\n\n XarrayVectorSpace.ones (coords:Optional[dict]=None)\n\nReturn XarrayVectorArray of vectors with each element equal to one in XarrayVectorSpace optionally extended to include supplied coordinates coords.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoords\nOptional\nNone\nCoordinates to extend vector space over\n\n\nReturns\nXarrayVectorArray\n\nXarrayVectorArray with all elements equal to one\n\n\n\n\nU = space.ones()\nU\n\n{foo(3) ⨉ bar(2), }\n\n\n\nU.array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'baz' (foo: 3, bar: 2)&gt; Size: 48B\narray([[1., 1.],\n       [1., 1.],\n       [1., 1.]])\nCoordinates:\n  * foo      (foo) int64 24B 1 2 3\n  * bar      (bar) &lt;U1 8B 'a' 'b'xarray.DataArray'baz'foo: 3bar: 21.0 1.0 1.0 1.0 1.0 1.0array([[1., 1.],\n       [1., 1.],\n       [1., 1.]])Coordinates: (2)foo(foo)int641 2 3array([1, 2, 3])bar(bar)&lt;U1'a' 'b'array(['a', 'b'], dtype='&lt;U1')Indexes: (2)fooPandasIndexPandasIndex(Index([1, 2, 3], dtype='int64', name='foo'))barPandasIndexPandasIndex(Index(['a', 'b'], dtype='object', name='bar'))Attributes: (0)\n\n\n\nspace.ones({'bam': [.2, .3, .4]})\n\n{foo(3) ⨉ bar(2), bam(3)}\n\n\n\nsource\n\n\nXarrayVectorSpace.random\n\n XarrayVectorSpace.random (coords=None, distribution='uniform', name=None)\n\n*Create a |VectorArray| of vectors with random entries.\nSupported random distributions::\n'uniform': Uniform distribution in half-open interval\n           [`low`, `high`).\n'normal':  Normal (Gaussian) distribution with mean\n           `loc` and standard deviation `scale`.\nNote that not all random distributions are necessarily implemented by all |VectorSpace| implementations.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoords\nNoneType\nNone\n\n\n\ndistribution\nstr\nuniform\nRandom distribution to use ('uniform', 'normal').\n\n\nname\nNoneType\nNone\n\n\n\nReturns\nXarrayVectorArray\n\nA random XarrayVectorArray in the vector space\n\n\n\n\nspace.random().array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'baz' (foo: 3, bar: 2)&gt; Size: 48B\narray([[0.67185419, 0.96058696],\n       [0.37091232, 0.42508177],\n       [0.81212296, 0.50576231]])\nCoordinates:\n  * foo      (foo) int64 24B 1 2 3\n  * bar      (bar) &lt;U1 8B 'a' 'b'xarray.DataArray'baz'foo: 3bar: 20.6719 0.9606 0.3709 0.4251 0.8121 0.5058array([[0.67185419, 0.96058696],\n       [0.37091232, 0.42508177],\n       [0.81212296, 0.50576231]])Coordinates: (2)foo(foo)int641 2 3array([1, 2, 3])bar(bar)&lt;U1'a' 'b'array(['a', 'b'], dtype='&lt;U1')Indexes: (2)fooPandasIndexPandasIndex(Index([1, 2, 3], dtype='int64', name='foo'))barPandasIndexPandasIndex(Index(['a', 'b'], dtype='object', name='bar'))Attributes: (0)\n\n\n\nspace.random({'bam': [1, 2, 3]}).array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'baz' (bam: 3, foo: 3, bar: 2)&gt; Size: 144B\narray([[[0.73657309, 0.45970946],\n        [0.21549514, 0.74520384],\n        [0.13115517, 0.19858366]],\n\n       [[0.62682498, 0.7472698 ],\n        [0.89468789, 0.2725865 ],\n        [0.11072426, 0.95604666]],\n\n       [[0.15442309, 0.19766698],\n        [0.29132945, 0.52939135],\n        [0.88282557, 0.76054602]]])\nCoordinates:\n  * bam      (bam) int64 24B 1 2 3\n  * foo      (foo) int64 24B 1 2 3\n  * bar      (bar) &lt;U1 8B 'a' 'b'xarray.DataArray'baz'bam: 3foo: 3bar: 20.7366 0.4597 0.2155 0.7452 0.1312 ... 0.2913 0.5294 0.8828 0.7605array([[[0.73657309, 0.45970946],\n        [0.21549514, 0.74520384],\n        [0.13115517, 0.19858366]],\n\n       [[0.62682498, 0.7472698 ],\n        [0.89468789, 0.2725865 ],\n        [0.11072426, 0.95604666]],\n\n       [[0.15442309, 0.19766698],\n        [0.29132945, 0.52939135],\n        [0.88282557, 0.76054602]]])Coordinates: (3)bam(bam)int641 2 3array([1, 2, 3])foo(foo)int641 2 3array([1, 2, 3])bar(bar)&lt;U1'a' 'b'array(['a', 'b'], dtype='&lt;U1')Indexes: (3)fooPandasIndexPandasIndex(Index([1, 2, 3], dtype='int64', name='foo'))barPandasIndexPandasIndex(Index(['a', 'b'], dtype='object', name='bar'))bamPandasIndexPandasIndex(Index([1, 2, 3], dtype='int64', name='bam'))Attributes: (0)\n\n\n\nspace.random().name\n\n'baz'\n\n\n\nspace.random(name='boo').name\n\n'boo'\n\n\n\nsource\n\n\nXarrayVectorSpace.ndim\n\n XarrayVectorSpace.ndim ()\n\nNumber of dimensions of the vector space.\n\nspace.ndim\n\n2\n\n\n\n# #| export\n# @patch(as_prop=True)\n# def ndim(self:XarrayVectorArray): return self.array.ndim\n\n\nsource\n\n\nXarrayVectorSpace.from_xarray\n\n XarrayVectorSpace.from_xarray (data:xarray.core.dataarray.DataArray)\n\nReturn an XarrayVectorArray containing data from DataArray data.\nA DataArray with the same coordinates as space:\n\nda = space.random().array\nda\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'baz' (foo: 3, bar: 2)&gt; Size: 48B\narray([[0.7822112 , 0.74799013],\n       [0.8150731 , 0.44824063],\n       [0.82055708, 0.24075307]])\nCoordinates:\n  * foo      (foo) int64 24B 1 2 3\n  * bar      (bar) &lt;U1 8B 'a' 'b'xarray.DataArray'baz'foo: 3bar: 20.7822 0.748 0.8151 0.4482 0.8206 0.2408array([[0.7822112 , 0.74799013],\n       [0.8150731 , 0.44824063],\n       [0.82055708, 0.24075307]])Coordinates: (2)foo(foo)int641 2 3array([1, 2, 3])bar(bar)&lt;U1'a' 'b'array(['a', 'b'], dtype='&lt;U1')Indexes: (2)fooPandasIndexPandasIndex(Index([1, 2, 3], dtype='int64', name='foo'))barPandasIndexPandasIndex(Index(['a', 'b'], dtype='object', name='bar'))Attributes: (0)\n\n\nAn XarrayVectorArray in space with data from da:\n\nspace.from_xarray(da)\n\n{foo(3) ⨉ bar(2), }\n\n\nAn XarrayVectorArray from an array in space plus extended dimensions:\n\nspace.from_xarray(space.random({'bam': [1, 2, 3]}).array)\n\n{foo(3) ⨉ bar(2), bam(3)}\n\n\n\nsource\n\n\nXarrayVectorSpace.from_numpy\n\n XarrayVectorSpace.from_numpy (data:numpy.ndarray, coords=None,\n                               extended_dim=None, id=None,\n                               ensure_copy=False)\n\nReturn an XarrayVectorArray in the vector space with data from the ndarray data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata\nndarray\n\n\n\n\ncoords\nNoneType\nNone\n\n\n\nextended_dim\nNoneType\nNone\n\n\n\nid\nNoneType\nNone\n\n\n\nensure_copy\nbool\nFalse\n\n\n\nReturns\nXarrayVectorArray\n\nA vector array with data from the numpy array\n\n\n\n\nspace.from_numpy(np.random.rand(space.dim * 2))\n\n{foo(3) ⨉ bar(2), len(2)}\n\n\n\n_.array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (len: 2, foo: 3, bar: 2)&gt; Size: 96B\narray([[[0.923492  , 0.3996791 ],\n        [0.17201775, 0.64397635],\n        [0.7543588 , 0.33183856]],\n\n       [[0.21263591, 0.09656027],\n        [0.05580018, 0.45084774],\n        [0.79418151, 0.91474573]]])\nCoordinates:\n  * foo      (foo) int64 24B 1 2 3\n  * bar      (bar) &lt;U1 8B 'a' 'b'\n  * len      (len) int64 16B 0 1xarray.DataArraylen: 2foo: 3bar: 20.9235 0.3997 0.172 0.644 0.7544 ... 0.0558 0.4508 0.7942 0.9147array([[[0.923492  , 0.3996791 ],\n        [0.17201775, 0.64397635],\n        [0.7543588 , 0.33183856]],\n\n       [[0.21263591, 0.09656027],\n        [0.05580018, 0.45084774],\n        [0.79418151, 0.91474573]]])Coordinates: (3)foo(foo)int641 2 3array([1, 2, 3])bar(bar)&lt;U1'a' 'b'array(['a', 'b'], dtype='&lt;U1')len(len)int640 1array([0, 1])Indexes: (3)fooPandasIndexPandasIndex(Index([1, 2, 3], dtype='int64', name='foo'))barPandasIndexPandasIndex(Index(['a', 'b'], dtype='object', name='bar'))lenPandasIndexPandasIndex(Index([0, 1], dtype='int64', name='len'))Attributes: (0)\n\n\n\nspace.from_numpy(np.random.rand(space.dim * 2), extended_dim={'time': [5, 7]})\n\n{foo(3) ⨉ bar(2), time(2)}\n\n\n\n_.array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (time: 2, foo: 3, bar: 2)&gt; Size: 96B\narray([[[0.03698541, 0.14551635],\n        [0.06159524, 0.37300236],\n        [0.38861432, 0.28252291]],\n\n       [[0.65541593, 0.8470817 ],\n        [0.76857619, 0.51632566],\n        [0.57151238, 0.88109368]]])\nCoordinates:\n  * foo      (foo) int64 24B 1 2 3\n  * bar      (bar) &lt;U1 8B 'a' 'b'\n  * time     (time) int64 16B 5 7xarray.DataArraytime: 2foo: 3bar: 20.03699 0.1455 0.0616 0.373 0.3886 ... 0.7686 0.5163 0.5715 0.8811array([[[0.03698541, 0.14551635],\n        [0.06159524, 0.37300236],\n        [0.38861432, 0.28252291]],\n\n       [[0.65541593, 0.8470817 ],\n        [0.76857619, 0.51632566],\n        [0.57151238, 0.88109368]]])Coordinates: (3)foo(foo)int641 2 3array([1, 2, 3])bar(bar)&lt;U1'a' 'b'array(['a', 'b'], dtype='&lt;U1')time(time)int645 7array([5, 7])Indexes: (3)fooPandasIndexPandasIndex(Index([1, 2, 3], dtype='int64', name='foo'))barPandasIndexPandasIndex(Index(['a', 'b'], dtype='object', name='bar'))timePandasIndexPandasIndex(Index([5, 7], dtype='int64', name='time'))Attributes: (0)\n\n\n\nsource\n\n\nXarrayVectorSpace.rename\n\n XarrayVectorSpace.rename (new_name_or_name_dict=None, **names)\n\n\nspace = XarrayVectorSpace({'A': [1, 2], 'B': ['a', 'b', 'c']}, name='boo')\nspace\n\n{A(2) ⨉ B(3)}\n\n\n\nspace.name\n\n'boo'\n\n\n\nspace.rename('foo').name\n\n'foo'\n\n\n\nsource\n\n\nXarrayVectorSpace.concatenate\n\n XarrayVectorSpace.concatenate (arrays, dim)\n\n\nsource\n\n\nXarrayVectorSpace.__eq__\n\n XarrayVectorSpace.__eq__ (other)\n\nReturn self==value.\n\nspace == space\n\nTrue\n\n\n\nspace == space.rename('foo')\n\nTrue\n\n\n\nsource\n\n\nXarrayVectorSpace.__mul__\n\n XarrayVectorSpace.__mul__ (other)\n\n\nspace2 = XarrayVectorSpace({'C': [1, 2], 'D': ['a', 'b', 'c']}, name='foo')\n\n\nspace3 = space * space2\nspace3\n\n{A(2) ⨉ B(3) ⨉ C(2) ⨉ D(3)}\n\n\n\nspace3 == XarrayVectorSpace(space.coords + space2.coords)\n\nTrue\n\n\n\nspace3.name\n\n'foo'\n\n\n\nspace2 * space2 == space2\n\nTrue\n\n\n\nsource\n\n\nXarrayVectorSpace.__contains__\n\n XarrayVectorSpace.__contains__ (other)\n\n\nspace in space2\n\nFalse\n\n\n\nspace in space\n\nTrue\n\n\n\nU = space.zeros({'foo': range(2)})\nU\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\nU in space\n\nTrue",
    "crumbs": [
      "API",
      "pymor",
      "pymor.vectorarrays"
    ]
  },
  {
    "objectID": "api/pymor/vectorarrays.html#xarrayvectorarray",
    "href": "api/pymor/vectorarrays.html#xarrayvectorarray",
    "title": "pymor.vectorarrays",
    "section": "XarrayVectorArray",
    "text": "XarrayVectorArray\n\nsource\n\nXarrayVectorArray.item\n\n XarrayVectorArray.item ()\n\nReturn the single value stored in the array if there is only one value.\n\nXarrayVectorSpace({'i': [0]}).ones().item()\n\n1.0\n\n\n\n# #| export\n# @patch(as_prop=True)\n# def dims(self:XarrayVectorArray): return self.array.dims\n\n\n# #| export\n# @patch(as_prop=True)\n# def extended_dims(self:XarrayVectorArrayImpl):\n#     return tuple(dim for dim in self._array.dims if dim not in self.space_array.dims)\n\n# @patch(as_prop=True)\n# def extended_dims(self:XarrayVectorArray):\n#     return self.impl.extended_dims\n\n\nsource\n\n\nXarrayVectorArray.extended_dims\n\n XarrayVectorArray.extended_dims ()\n\n\nU = space.zeros({'foo': range(2)})\nU\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\nU.extended_dims\n\n('foo',)\n\n\n\nU.space.dims\n\n('A', 'B')\n\n\n\n\n\nVectorArray.to_numpy\n\n VectorArray.to_numpy (ensure_copy=False)\n\nReturn (len(self), self.dim) NumPy Array with the data stored in the array.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nensure_copy\nbool\nFalse\nIf False, modifying the returned |NumPy array| might alter the original|VectorArray|. If True always a copy of the array data is made.\n\n\n\n\nU.array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'boo' (foo: 2, A: 2, B: 3)&gt; Size: 96B\narray([[[0., 0., 0.],\n        [0., 0., 0.]],\n\n       [[0., 0., 0.],\n        [0., 0., 0.]]])\nCoordinates:\n  * foo      (foo) int64 16B 0 1\n  * A        (A) int64 16B 1 2\n  * B        (B) &lt;U1 12B 'a' 'b' 'c'xarray.DataArray'boo'foo: 2A: 2B: 30.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0array([[[0., 0., 0.],\n        [0., 0., 0.]],\n\n       [[0., 0., 0.],\n        [0., 0., 0.]]])Coordinates: (3)foo(foo)int640 1array([0, 1])A(A)int641 2array([1, 2])B(B)&lt;U1'a' 'b' 'c'array(['a', 'b', 'c'], dtype='&lt;U1')Indexes: (3)APandasIndexPandasIndex(Index([1, 2], dtype='int64', name='A'))BPandasIndexPandasIndex(Index(['a', 'b', 'c'], dtype='object', name='B'))fooPandasIndexPandasIndex(Index([0, 1], dtype='int64', name='foo'))Attributes: (0)\n\n\n\nU.to_numpy()\n\narray([[0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.]])\n\n\n\nspace.zeros(space2.coords).shape\n\n(2, 3, 2, 3)\n\n\n\nspace.zeros(space2.coords).to_numpy().shape\n\n(6, 6)\n\n\n\nsource\n\n\nXarrayVectorArray.rename\n\n XarrayVectorArray.rename (new_name_or_name_dict=None, **names)\n\nRename the vector array and/or any of its dimensions.\n\nU.rename('baz', A='bar')\n\n{bar(2) ⨉ B(3), foo(2)}\n\n\n\nsource\n\n\nXarrayVectorArray.__mul__\n\n XarrayVectorArray.__mul__ (other)\n\n\nU1 = space.ones({'foo': [0, 1]})\n\n\nda = DataArray(np.arange(3), {'B': U1.array.B})\n\n\nU1 * da\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\n_.array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'XarrayVectorArray' (foo: 2, A: 2, B: 3)&gt; Size: 96B\narray([[[0., 1., 2.],\n        [0., 1., 2.]],\n\n       [[0., 1., 2.],\n        [0., 1., 2.]]])\nCoordinates:\n  * foo      (foo) int64 16B 0 1\n  * A        (A) int64 16B 1 2\n  * B        (B) &lt;U1 12B 'a' 'b' 'c'xarray.DataArray'XarrayVectorArray'foo: 2A: 2B: 30.0 1.0 2.0 0.0 1.0 2.0 0.0 1.0 2.0 0.0 1.0 2.0array([[[0., 1., 2.],\n        [0., 1., 2.]],\n\n       [[0., 1., 2.],\n        [0., 1., 2.]]])Coordinates: (3)foo(foo)int640 1array([0, 1])A(A)int641 2array([1, 2])B(B)&lt;U1'a' 'b' 'c'array(['a', 'b', 'c'], dtype='&lt;U1')Indexes: (3)fooPandasIndexPandasIndex(Index([0, 1], dtype='int64', name='foo'))APandasIndexPandasIndex(Index([1, 2], dtype='int64', name='A'))BPandasIndexPandasIndex(Index(['a', 'b', 'c'], dtype='object', name='B'))Attributes: (0)\n\n\n\nspace.ones()\n\n{A(2) ⨉ B(3), }\n\n\n\nspace2.zeros()\n\n{C(2) ⨉ D(3), }\n\n\n\nspace.ones() * space2.zeros()\n\n{A(2) ⨉ B(3) ⨉ C(2) ⨉ D(3), }\n\n\n\nspace = XarrayVectorSpace({'A': [1, 2], 'B': ['a', 'b', 'c']}, name='boo')\nspace\n\n{A(2) ⨉ B(3)}\n\n\n\nU = space.zeros({'foo': range(2)})\nU\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\nU\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\nU.reim\n\n{A(2) ⨉ B(3), foo(2) ⨉ Part(2)}\n\n\n\nU.real\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\nU.imag\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\nU.conj()\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\nspace = XarrayVectorSpace({'A': [1, 2], 'B': ['a', 'b', 'c']}, name='boo')\nspace\n\n{A(2) ⨉ B(3)}\n\n\n\nU = space.zeros({'foo': range(2)})\nU\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\nU.scal(0.)\n\n\nU\n\n{A(2) ⨉ B(3), foo(2)}\n\n\n\n# #| export\n# def _plotly_automargin(plot, element):\n#     plot.state['layout']['yaxis']['automargin'] = True\n#     plot.state['layout']['xaxis']['automargin'] = True\n\n\n# #| export\n# def _delete(string, strings):\n#     for s in strings: string = string.replace(s, '')\n#     return string\n\n\n# #| export\n# def _set_scrubber_fractional_value(column, fraction): \n#     scrubber = column.objects[1].objects[0]\n#     scrubber.value = round(scrubber.end * fraction)\n\n\n# #| export\n# def _scaled_loc(arr, fraction):\n#     return arr[int(len(arr) * fraction)]\n\n\nsource\n\n\nXarrayVectorArray.visualize\n\n XarrayVectorArray.visualize (slider_label_precision=2)\n\nVisualize the data contained in the XarrayVectorArray. Put the first dimension with numerical coordinates on the x axis, and include a scrubber if there is a second numerical dimension. Atomic velocity is prioritized to be on the x axis, time is prioritized to be on the scrubber. Put categorical dimensions in the legend. If the data are complex, add the real and imaginary parts as a categorical dimension. If there are no numerical dimensions, plot the categorical dimension(s) as a horizontal bar plot.\n\nspace = XarrayVectorSpace(coords={'foo': ['aaaaaaaaaaaaaaaaaa', 'b', 'c']})\nU1 = space.random(name='bar')\nU2 = 1j * space.random(name='bar')\nU3 = space.random({'baz': np.arange(5)}, name='bar')\nU4 = 1j * space.random({'baz': np.arange(5)}, name='bar')\nU5 = space.random({'baz': np.arange(5), 'bing': .000123456 * np.linspace(0, 5, 6)}, name='bar')\n\n\nU1.visualize()\n\n                                                \n\n\n\n(U1 + U2).visualize()\n\n                                                \n\n\n\nU3.visualize(line_width=10)\n\n                                                \n\n\n\nU3.visualize(title='biz', markers=True, xaxis_range=(.5, 3), line_width=0)\n\n                                                \n\n\n\n(U3 + U4).visualize()\n\n                                                \n\n\n\nU5.visualize(slider_label_precision=5)\n\n                                                \n\n\n\n# #| export\n# def _sort_varables(vars, head=set(), tail=set()):\n#     vars = set(vars)\n#     return (\n#         list(set.intersection(vars, head)) \n#         + list(vars - head - tail)\n#         + list(set.intersection(vars, tail))\n#     )\n\n\n# #| export\n# def _apply_opts(obj, **opts):\n#     \"\"\"Traverse a holoviews object and apply `opts` to it or any child of it that accepts them.\"\"\"\n#     if hasattr(obj, 'opts'): obj = obj.opts(**opts)\n#     if hasattr(obj, 'object') and hasattr(obj.object, 'opts'): _apply_opts(obj.object, **opts)\n#     if hasattr(obj, 'objects'):\n#         for o in obj.objects:\n#             _apply_opts(o, **opts)\n\n\n# #| export\n# def _plotly_trim_legend_label(plot, element):\n#     plot.state['data'][0]['name'] = ', '.join(s.split(': ')[1] for s in plot.state['data'][0]['name'].split(', '))",
    "crumbs": [
      "API",
      "pymor",
      "pymor.vectorarrays"
    ]
  },
  {
    "objectID": "api/pymor/grids.html",
    "href": "api/pymor/grids.html",
    "title": "pymor.grids",
    "section": "",
    "text": "source\n\nOnedUnstructuredGrid\n\n OnedUnstructuredGrid (edges, identify_left_right=False)\n\nOne-dimensional |Grid| on an interval.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nedges\n\n\nSequence specifying the edges of the grid intervals.\n\n\nidentify_left_right\nbool\nFalse\nWhether the left and right edges of the grid should be identified.\n\n\n\n\ngrid = OnedUnstructuredGrid([1., 1.2, 1.7, 2.5])\n\n\ngrid.embeddings(0)\n\n(array([[[0.2]],\n \n        [[0.5]],\n \n        [[0.8]]]),\n array([[1. ],\n        [1.2],\n        [1.7]]))\n\n\n\ngrid.embeddings(1)\n\n(array([], shape=(4, 1, 0), dtype=float64),\n array([[1. ],\n        [1.2],\n        [1.7],\n        [2.5]]))\n\n\n\ngrid.centers(0)\n\narray([[1.1 ],\n       [1.45],\n       [2.1 ]])\n\n\n\ngrid.centers(1)\n\narray([[1. ],\n       [1.2],\n       [1.7],\n       [2.5]])",
    "crumbs": [
      "API",
      "pymor",
      "pymor.grids"
    ]
  },
  {
    "objectID": "api/pymor/models.html",
    "href": "api/pymor/models.html",
    "title": "pymor.models",
    "section": "",
    "text": "source\n\nStationaryModel\n\n StationaryModel (operator, rhs, output_functional=None, products=None,\n                  error_estimator=None, visualizer=None, name=None,\n                  data=None)\n\nExtend pyMOR’s StationaryModel to include a data attribute for storing, e.g., the model’s grid.\n\nsource\n\n\nStationaryModel.solve\n\n StationaryModel.solve (mu=None, input=None, return_error_estimate=False,\n                        **kwargs)\n\nExtend StationaryModel.solve to solve over a range of parameters.\n\nsource\n\n\nInstationaryModel\n\n InstationaryModel (T, initial_data, operator, rhs, mass=None,\n                    time_stepper=None, num_values=None,\n                    output_functional=None, products=None,\n                    error_estimator=None, visualizer=None, name=None,\n                    data=None)\n\nExtend pyMOR’s InstationaryModel to include a data attribute for storing, e.g., the model’s grid.\n\nsource\n\n\nfloquet_reconstruction\n\n floquet_reconstruction (n_vector, time)\n\n\nsource\n\n\nStationaryFloquetModel\n\n StationaryFloquetModel (operator, rhs, mu, n_vector, nu:nu,\n                         n_operator=None, products=None, name=None,\n                         data=None)\n\nA model that solves for the Fourier coefficients of the periodic state of a modulated system.",
    "crumbs": [
      "API",
      "pymor",
      "pymor.models"
    ]
  },
  {
    "objectID": "api/dmelements.html",
    "href": "api/dmelements.html",
    "title": "dmelements",
    "section": "",
    "text": "source\n\nparse_dm_element\n\n parse_dm_element (s)\n\n\nsource\n\n\npopulation_element\n\n population_element (s)\n\n\nsource\n\n\npopulation\n\n population (dm_elements)\n\n\nsource\n\n\nlevel_label\n\n level_label (expr:str)\n\n\nsource\n\n\nlevel_label\n\n level_label (expr:str)\n\n\nsource\n\n\nlevels\n\n levels (dm_elements)\n\n\nsource\n\n\nlevel_population\n\n level_population (dm_elements)\n\n\nsource\n\n\nsum_over_dm\n\n sum_over_dm (dm_elements)",
    "crumbs": [
      "API",
      "dmelements"
    ]
  },
  {
    "objectID": "api/utilities/sparse.html",
    "href": "api/utilities/sparse.html",
    "title": "utilities.sparse",
    "section": "",
    "text": "source\n\nsparse2d\n\n sparse2d (a)\n\nCreate a 2D sparse array in specified format.\n\narrays = [np.identity(2), sps.eye(2), ss.eye(2), ss.eye(2, format='gcxs')]\n[sparse2d(args) for args in arrays]\n\n[&lt;2x2 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 2 stored elements in Compressed Sparse Row format&gt;,\n &lt;2x2 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 2 stored elements in Compressed Sparse Row format&gt;,\n &lt;2x2 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 2 stored elements in Compressed Sparse Row format&gt;,\n &lt;2x2 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 2 stored elements in Compressed Sparse Row format&gt;]\n\n\n\nsource\n\n\nsparse\n\n sparse (a, format='coo', shape=None, has_duplicates=True, sorted=False,\n         prune=False, cache=False, fill_value=None, idx_dtype=None)\n\nCreate an N-D sparse array in specified format.\n\narrays = [np.identity(2), sps.eye(2), ss.eye(2), [[[0, 1], [0, 1]], [1., 1.]]]\n[sparse(*args) for args in it.product(arrays, ['coo', 'gcxs'])]\n\n[&lt;COO: shape=(2, 2), dtype=float64, nnz=2, fill_value=0.0&gt;,\n &lt;GCXS: shape=(2, 2), dtype=float64, nnz=2, fill_value=0.0, compressed_axes=(0,)&gt;,\n &lt;COO: shape=(2, 2), dtype=float64, nnz=2, fill_value=0.0&gt;,\n &lt;GCXS: shape=(2, 2), dtype=float64, nnz=2, fill_value=0, compressed_axes=(0,)&gt;,\n &lt;COO: shape=(2, 2), dtype=float64, nnz=2, fill_value=0.0&gt;,\n &lt;GCXS: shape=(2, 2), dtype=float64, nnz=2, fill_value=0.0, compressed_axes=(0,)&gt;,\n &lt;COO: shape=(2, 2), dtype=float64, nnz=2, fill_value=0.0&gt;,\n &lt;GCXS: shape=(2, 2), dtype=float64, nnz=2, fill_value=0.0, compressed_axes=(0,)&gt;]\n\n\n\nsource\n\n\nsparse2d_identity\n\n sparse2d_identity (n)\n\n\nsparse2d_identity(2)\n\n&lt;2x2 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 2 stored elements (1 diagonals) in DIAgonal format&gt;\n\n\n\nsource\n\n\nsparse_identity\n\n sparse_identity (n, format='coo')\n\n\n[sparse_identity(2, format=fmt) for fmt in ['coo', 'gcxs']]\n\n[&lt;COO: shape=(2, 2), dtype=float64, nnz=2, fill_value=0.0&gt;,\n &lt;GCXS: shape=(2, 2), dtype=float64, nnz=2, fill_value=0.0, compressed_axes=(0,)&gt;]\n\n\n\nsource\n\n\nsparse2d_diag\n\n sparse2d_diag (diags, offsets=0)\n\n\nsparse2d_diag([1, 1])\n\n&lt;2x2 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 2 stored elements (1 diagonals) in DIAgonal format&gt;\n\n\n\nsource\n\n\nsparse_diag\n\n sparse_diag (diag, format='coo')\n\n\nsparse_diag([1, 1])\n\n\n\n\nFormat\ncoo\n\n\nData Type\nfloat64\n\n\nShape\n(2, 2)\n\n\nnnz\n2\n\n\nDensity\n0.5\n\n\nRead-only\nTrue\n\n\nSize\n32\n\n\nStorage ratio\n1.00\n\n\n\n\n\n\nsource\n\n\ndense_toeplitz\n\n dense_toeplitz (diags:numpy.ndarray)\n\nReturn a toeplitz array given the value on each diagonal (starting at lower left).\n\n\n\n\nType\nDetails\n\n\n\n\ndiags\nndarray\nValue on each diagonal, starting at lower left.\n\n\n\n\ndense_toeplitz([1, 2, 3])\n\narray([[2, 3],\n       [1, 2]])\n\n\n\nsource\n\n\nsparse_toeplitz\n\n sparse_toeplitz (diags:numpy.ndarray, format='coo')\n\nReturn a toeplitz sparse array in specified format given the value on each diagonal (starting at lower left).\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndiags\nndarray\n\nValue on each diagonal, starting at lower left.\n\n\nformat\nstr\ncoo\n\n\n\nReturns\nSparseArray\n\n\n\n\n\n\nsparse_toeplitz([1, 2, 3, 4, 5])\n\n\n\n\nFormat\ncoo\n\n\nData Type\nint64\n\n\nShape\n(3, 3)\n\n\nnnz\n9\n\n\nDensity\n1.0\n\n\nRead-only\nTrue\n\n\nSize\n216\n\n\nStorage ratio\n3.00\n\n\n\n\n\n\n_.todense()\n\narray([[3, 4, 5],\n       [2, 3, 4],\n       [1, 2, 3]])\n\n\n\nsource\n\n\nsparse2d_kronecker_matrix\n\n sparse2d_kronecker_matrix (n, k=0)\n\nThe nxn sparse kronecker matrix delta_(i,j-k) in specified format.\n\nsparse2d_kronecker_matrix(3, 2)\n\n&lt;3x3 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 1 stored elements (1 diagonals) in DIAgonal format&gt;\n\n\n\n_.todense()\n\narray([[0., 0., 1.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n\n\n\nsource\n\n\nsparse_kronecker_matrix\n\n sparse_kronecker_matrix (n, k=0, format='coo')\n\nThe nxn sparse kronecker matrix delta_(i,j-k) in specified format.\n\nsparse_kronecker_matrix(3, 2)\n\n\n\n\nFormat\ncoo\n\n\nData Type\nfloat64\n\n\nShape\n(3, 3)\n\n\nnnz\n1\n\n\nDensity\n0.1111111111111111\n\n\nRead-only\nTrue\n\n\nSize\n16\n\n\nStorage ratio\n0.22\n\n\n\n\n\n\nsource\n\n\nkron\n\n kron (a, b, *rest)\n\n\nkron(np.eye(2), np.eye(2), np.eye(2))\n\narray([[1., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 1., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 1., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 1., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 1., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 1.]])\n\n\n\nkron(*[sparse2d_identity(2)] * 3)\n\n&lt;8x8 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 8 stored elements in Compressed Sparse Row format&gt;\n\n\n\nsparse2d_rand([2, 3])\n\n&lt;2x3 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 0 stored elements in COOrdinate format&gt;\n\n\n\nsource\n\n\nrestrict_bandwidth\n\n restrict_bandwidth (a_sparray:scipy.sparse._base.sparray, width)\n\nMake a scipy sparse array banded by setting all elements outside the bandwidth to zero.\n\nrestrict_bandwidth(sps.csr_array(np.ones((5, 5))), 1)\n\n&lt;5x5 sparse array of type '&lt;class 'numpy.float64'&gt;'\n    with 13 stored elements in Compressed Sparse Row format&gt;\n\n\n\n_.toarray()\n\narray([[1., 1., 0., 0., 0.],\n       [1., 1., 1., 0., 0.],\n       [0., 1., 1., 1., 0.],\n       [0., 0., 1., 1., 1.],\n       [0., 0., 0., 1., 1.]])",
    "crumbs": [
      "API",
      "utilities",
      "utilities.sparse"
    ]
  },
  {
    "objectID": "api/utilities/index.html",
    "href": "api/utilities/index.html",
    "title": "utilities",
    "section": "",
    "text": "This section contains API details for utility functions implemented for pyLGS.\n\n\n\n\n\n\n\n\n\nTitle\n\n\nDescription\n\n\n\n\n\n\nutilities.basic\n\n\nBasic python utility functions\n\n\n\n\nutilities.formatting\n\n\nFormatting functions\n\n\n\n\nutilities.nbdev\n\n\nExtra functionality for nbdev\n\n\n\n\nutilities.numpy\n\n\nExtra functionality for NumPy\n\n\n\n\nutilities.sparse\n\n\nExtra functionality for sparse and scipy.sparse\n\n\n\n\nutilities.testing\n\n\nTesting utilities\n\n\n\n\nutilities.xarray\n\n\nExtra functionality for xarray\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "API",
      "utilities"
    ]
  },
  {
    "objectID": "api/utilities/basic.html",
    "href": "api/utilities/basic.html",
    "title": "utilities.basic",
    "section": "",
    "text": "source\n\nget_item\n\n get_item (l:Sequence, i:int, default:Optional=None)\n\nReturn item at index i from sequence l or default if item does not exist.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nl\nSequence\n\nSequence to get item of\n\n\ni\nint\n\nIndex of item to get\n\n\ndefault\nOptional\nNone\nDefault value to return if sequence does not contain item at index\n\n\nReturns\nAny\n\nItem or default value\n\n\n\n\nget_item('abc', 1)\n\n'b'\n\n\n\nget_item('abc', 4, \"foo\")\n\n'foo'\n\n\n\nstr(get_item('abc', 4))\n\n'None'\n\n\n\nsource\n\n\nfilter_args\n\n filter_args (fnc:Callable, **kwargs)\n\nReturn only keyword arguments defined in signature of function fnc.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfnc\nCallable\nFunction to test keyword arguments against\n\n\nkwargs\n\n\n\n\nReturns\ndict\nKeyword arguments defined in signature of fnc\n\n\n\n\nfilter_args(get_item, default=3, foo='bar')\n\n{'default': 3}\n\n\n\nsource\n\n\nfilter_out_args\n\n filter_out_args (fnc:Callable, **kwargs)\n\nReturn only keyword arguments not defined in signature of function fnc.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfnc\nCallable\nFunction to test keyword arguments against\n\n\nkwargs\n\n\n\n\nReturns\ndict\nKeyword arguments not defined in signature of fnc\n\n\n\n\nfilter_out_args(get_item, default=3, foo='bar')\n\n{'foo': 'bar'}",
    "crumbs": [
      "API",
      "utilities",
      "utilities.basic"
    ]
  },
  {
    "objectID": "api/utilities/nbdev.html",
    "href": "api/utilities/nbdev.html",
    "title": "utilities.nbdev",
    "section": "",
    "text": "Based on nbdev DocmentTbl.\n\nsource\n\nMarkdownTable\n\n MarkdownTable (data, headers)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nDictTbl\n\n DictTbl (obj)\n\nInitialize self. See help(type(self)) for accurate signature.\n\ndef _test_dict(): \n    return {\n        'foo': [1, 2], # First item description\n        'bar': [3, 4], # Item description No. 2\n        'baz': [5, 6], # The last description\n    }\n\n\nDictTbl(_test_dict)\n\n\n\n\n\nDescription\n\n\n\n\nfoo\nFirst item description\n\n\nbar\nItem description No. 2\n\n\nbaz\nThe last description\n\n\n\n\n\n\nstr(DictTbl(_test_dict))\n\n'|   | **Description** |\\n| - | --------------- |\\n| foo | First item description |\\n| bar | Item description No. 2 |\\n| baz | The last description |'\n\n\n\nsource\n\n\nAttributeTbl\n\n AttributeTbl (obj)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nclass _test_class:\n    \"\"\"A test class for the AttributeTbl class.\"\"\"\n    \n    class_variable = 'foo'\n    \n    def __init__(\n        self, \n        bar:str, # bar parameter\n        baz # baz parameter\n    ):\n        a = 3\n        self.b = 4 # An attribute\n        self.bing = 5 # Another attribute\n        c = 6\n\n\nAttributeTbl(_test_class)\n\n\n\n\nAttribute\nDescription\n\n\n\n\nb\nAn attribute\n\n\nbing\nAnother attribute\n\n\n\n\n\n\nstr(AttributeTbl(_test_class))\n\n'| **Attribute** | **Description** |\\n| ------------- | --------------- |\\n| b | An attribute |\\n| bing | Another attribute |'",
    "crumbs": [
      "API",
      "utilities",
      "utilities.nbdev"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "API",
    "section": "",
    "text": "This section contains API details for pyLGS.\n\n\n\n\n\n\n\n\n\nTitle\n\n\nDescription\n\n\n\n\n\n\ndmelements\n\n\nOperators on density-matrix elements\n\n\n\n\nlgssystem\n\n\nDefine and solve models for LGS systems\n\n\n\n\npymor\n\n\n\n\n\n\n\npymor.grids\n\n\nExtended functionality for pyMOR grids\n\n\n\n\npymor.models\n\n\nExtended functionality for pyMOR models\n\n\n\n\npymor.operators\n\n\nExtended functionality for pyMOR operators\n\n\n\n\npymor.parameters\n\n\nExtended functionality for pyMOR parameters\n\n\n\n\npymor.timestepping\n\n\nExtended functionality for pyMOR time steppers\n\n\n\n\npymor.vectorarrays\n\n\nExtended functionality for pyMOR vector arrays\n\n\n\n\nutilities\n\n\n\n\n\n\n\nutilities.basic\n\n\nBasic python utility functions\n\n\n\n\nutilities.formatting\n\n\nFormatting functions\n\n\n\n\nutilities.nbdev\n\n\nExtra functionality for nbdev\n\n\n\n\nutilities.numpy\n\n\nExtra functionality for NumPy\n\n\n\n\nutilities.sparse\n\n\nExtra functionality for sparse and scipy.sparse\n\n\n\n\nutilities.testing\n\n\nTesting utilities\n\n\n\n\nutilities.xarray\n\n\nExtra functionality for xarray\n\n\n\n\nvelocitygroups\n\n\nCreate and manipulate a list of bins of the atomic velocity distribution for use in the LGS model\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "API"
    ]
  },
  {
    "objectID": "api/velocitygroups.html",
    "href": "api/velocitygroups.html",
    "title": "velocitygroups",
    "section": "",
    "text": "source\n\nVelocityGroups\n\n VelocityGroups (bins:Union[Iterable,int]=6)\n\nVelocityGroups contains informations about the centers, edges, and relative densities of a list of velocity group bins.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nbins\nUnion\n6\nIterable of velocity group edges or int specifying number of evenly spaced velocity groups\n\n\n\nCreate a list of two evenly spaced velocity groups:\n\nvg = VelocityGroups(2)\nvg\n\n{'VGCenter': array([  -1.5  ,    1.5  ]),\n 'VGDensity': array([   0.5  ,    0.5  ]),\n 'VGWidth': array([   3.0  ,    3.0  ]),\n 'VGInverseWidth': array([  0.33  ,   0.33  ]),\n 'VGNumber': 2,\n 'velocity_groups': array([   1.0  ,    1.0  ])}\n\n\n\nsource\n\n\nVelocityGroups.subdivide\n\n VelocityGroups.subdivide (indices:int|numpy.ndarray|slice=slice(None,\n                           None, None))\n\nDivide the velocity groups with indices indices in two.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nindices\nint | numpy.ndarray | slice\nslice(None, None, None)\nIndices, boolean array, or slice object specifying velocity groups to subdivide\n\n\n\nReturn a new VelocityGroups object with the groups at index 1 divided in two:\n\nvg.subdivide([1])\n\n{'VGCenter': array([  -1.5  ,   0.75  ,    2.2  ]),\n 'VGDensity': array([   0.5  ,   0.48  ,   0.017 ]),\n 'VGWidth': array([   3.0  ,    1.5  ,    1.5  ]),\n 'VGInverseWidth': array([  0.33  ,   0.67  ,   0.67  ]),\n 'VGNumber': 3,\n 'velocity_groups': array([   1.0  ,    1.0  ,    1.0  ])}\n\n\n\nsource\n\n\nVelocityGroups.identity\n\n VelocityGroups.identity ()\n\nThe velocity-space identity operator.\n\nvg.identity()\n\nX{AV(2)} → {AV(2)}\n\n\n\n_.to_numpy()\n\narray([[   1.0  ,     0   ],\n       [    0   ,    1.0  ]])\n\n\n\nsource\n\n\nVelocityGroups.velocity_diagonal\n\n VelocityGroups.velocity_diagonal ()\n\nA velocity-space operator with the velocity on the diagonal.\n\nvg.velocity_diagonal()\n\nX{AV(2)} → {AV(2)}\n\n\n\n_.to_numpy()\n\narray([[  -1.5  ,     0   ],\n       [    0   ,    1.5  ]])\n\n\n\nsource\n\n\nvelocity_density_vector\n\n velocity_density_vector (vg)\n\n\nsource\n\n\nVelocityGroups.n_times_1\n\n VelocityGroups.n_times_1 ()\n\nOperator that sums over all velocity groups then scales by the Maxwell-Boltzmann distribution.\n\nvg.n_times_1()\n\nX{AV(2)} → {AV(2)}\n\n\n\n_.to_numpy()\n\narray([[   0.5  ,    0.5  ],\n       [   0.5  ,    0.5  ]])\n\n\n\nsource\n\n\nVelocityGroups.drho_dv\n\n VelocityGroups.drho_dv ()\n\nDerivative with respect to velocity operator.$\n\nvg.drho_dv()\n\nX{AV(2)} → {AV(2)}\n\n\n\n_.to_numpy()\n\narray([[  0.33  ,     0   ],\n       [ -0.33  ,   0.33  ]])\n\n\n\nsource\n\n\nVelocityGroups.normalize\n\n VelocityGroups.normalize ()\n\nReturns the operator that normalizes a vector by dividing each component by the width of the corresponding velocity group.\n\nvg.normalize()\n\nS{AV(2)} → {AV(2)}\n\n\n\nsource\n\n\nVelocityGroups.sum\n\n VelocityGroups.sum ()\n\nReturns the operator that sums a vector over velocity groups.\n\nvg.sum()\n\n∑{AV(2)} → {1}",
    "crumbs": [
      "API",
      "velocitygroups"
    ]
  },
  {
    "objectID": "api/lgssystem.html",
    "href": "api/lgssystem.html",
    "title": "lgssystem",
    "section": "",
    "text": "source\n\nLGSSystem\n\n LGSSystem (system:str, fixed_params:dict={})\n\nLGSSystem creates numerical models for the chosen laser guide star atomic system.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsystem\nstr\n\nName of the atomic system to be loaded from file\n\n\nfixed_params\ndict\n{}\nValues for system parameters that will be held fixed\n\n\n\n\nsource\n\n\nLGSSystem.builtins\n\n LGSSystem.builtins ()\n\nList the available LGS systems:\n\nLGSSystem.builtins()\n\n['NaD1', 'Na330', 'NaD2', 'NaD2_Repump', 'NaD1_Toy']\n\n\n\nsource\n\n\nLGSSystem.diagram\n\n LGSSystem.diagram (name:str|pathlib.Path, kind='Toy')\n\nDraw a level diagram for the system of the specified kind.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr | pathlib.Path\n\nName of built-in LGS system definition, or directory of supplied system\n\n\nkind\nstr\nToy\n“Toy” to show level diagram and pumped transitions, “ToScale” to show hyperfine structure to scale, “NotToScale” to show unscaled hf structure\n\n\n\n\nLGSSystem.diagram(\"Na330\", \"Toy\")\n\n\n\n\n\n\n\n\n\nLGSSystem.diagram(\"Na330\", \"ToScale\")\n\n\n\n\n\n\n\n\n\nLGSSystem.diagram(\"Na330\", \"NotToScale\")\n\n\n\n\n\n\n\n\n\nsource\n\n\nLGSSystem.info\n\n LGSSystem.info (name:str|pathlib.Path)\n\nDisplay information about LGS system name.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nname\nstr | pathlib.Path\nName of built-in LGS system definition, or directory of supplied system\n\n\n\n\nLGSSystem.info(\"NaD2_Repump\")\n\nAtomic levels\n\\(\\text{3S}_{\\frac{1}{2}}\\), \\(\\text{3P}_{\\frac{3}{2}}\\) #### Pump transitions 1. \\(\\text{3S}_{\\frac{1}{2}}\\land F=1\\to \\text{3P}_{\\frac{3}{2}}\\) 1. \\(\\text{3S}_{\\frac{1}{2}}\\land F=2\\to \\text{3P}_{\\frac{3}{2}}\\) #### Transition wavelengths - \\(\\text{3P}_{\\frac{3}{2}}\\to \\text{3S}_{\\frac{1}{2}}\\): 589.158 nm #### Substructure - Hyperfine structure included - Zeeman structure included - 24 total sublevels #### Density matrix elements - All populations included - All Zeeman coherences (between same level and same F) included - All hyperfine coherences (between same level and different F) neglected - Optical coherences (between different levels) included for pump transitions only - 374 density matrix elements total #### Input parameters - BeamTransitRatePerS - BFieldG - MagneticAzimuthDegrees - MagneticZenithDegrees - RecoilParameter - SDampingCollisionRatePerS - TemperatureK - VccRatePerS - DetuningHz1 - DetuningHz2 - EllipticityDegrees1 - EllipticityDegrees2 - IntensitySI1 - IntensitySI2 - LaserWidthHz1 - LaserWidthHz2 - PolarizationAngleDegrees1 - PolarizationAngleDegrees2\n\n\nLoad a “toy” (no angular momentum) model LGS system and fix values for most of the parameters:\n\nlgs = LGSSystem(\n    'NaD1_Toy',\n    fixed_params={'EllipticityDegrees1': 45.0,\n                  'PolarizationAngleDegrees1': 0,\n                  'DetuningHz1': 0,\n                  'LaserWidthHz1': 10.0e6,\n                  'BFieldG': 0.5,\n                  'MagneticZenithDegrees': 45.0,\n                  'MagneticAzimuthDegrees': 45.0,\n                  'SDampingCollisionRatePerS': 4e3,\n                  'BeamTransitRatePerS': 1e2,\n                  'VccRatePerS': 3e4,\n                  'TemperatureK': 2e2,\n                  'RecoilParameter': 1,\n                 }\n)\n\nThe only remaining parameter is the laser intensity. Here the value 1 indicates that the parameter is a scalar quantity:\n\nlgs.parameters\n\nParameters({IntensitySI1: 1})\n\n\nDefine a value for the intensity to use for the following examples:\n\nmu = Mu(IntensitySI1=46.)\n\n\nsource\n\n\nLGSSystem.operator\n\n LGSSystem.operator (vg:pylgs.velocitygroups.VelocityGroups)\n\nThe evolution operatior for the system, given the VelocityGroups vg.\n\n\n\n\nType\nDetails\n\n\n\n\nvg\nVelocityGroups\nVelocityGroups specification\n\n\nReturns\nOperator\n\n\n\n\nForm the operator with the example VelocityGroups:\n\nop = lgs.operator(vg)\n\nThe operator operates on vectors from the \\(2\\times4\\) (velocity \\(\\times\\) density matrix) product vector space:\n\nop.source\n\n{Atomic velocity(2) ⨉ Density matrix (source)(4)}\n\n\nAnd returns a vector from the same space:\n\nop.range\n\n{Atomic velocity (range)(2) ⨉ Density matrix (range)(4)}\n\n\nSubstitute the free parameter values into the operator and write it explicitly as a block matrix, with \\(2\\times2\\) blocks for the velocity space, each block being \\(4\\times4\\) on the density matrix space:\n\nto_matrix(op, mu=mu).toarray()/1e6\n\narray([[  0.015 ,     0   , -2.6e+01, -6.1e+01,  -0.015 ,     0   ,     0   ,     0   ],\n       [    0   ,  6.2e+01, -6.1e+03,     0   ,     0   ,     0   ,     0   ,     0   ],\n       [ 1.3e+01,  6.1e+03,  6.2e+01, -1.3e+01,     0   ,     0   ,     0   ,     0   ],\n       [    0   ,     0   ,  2.6e+01,  6.1e+01,     0   ,     0   ,     0   ,  -0.015 ],\n       [ -0.015 ,     0   ,     0   , -0.0016 ,   0.015 ,     0   , -2.6e+01, -6.1e+01],\n       [    0   ,     0   ,     0   ,     0   ,     0   ,  6.2e+01,  6.1e+03,     0   ],\n       [    0   ,     0   ,     0   ,     0   ,  1.3e+01, -6.1e+03,  6.2e+01, -1.3e+01],\n       [    0   ,     0   ,     0   ,  -0.015 ,     0   ,     0   ,  2.6e+01,  6.1e+01]])\n\n\n\nsource\n\n\nLGSSystem.rhs\n\n LGSSystem.rhs (vg:pylgs.velocitygroups.VelocityGroups)\n\nThe right-hand side vector for this system given the VelocityGroups vg.\n\n\n\n\nType\nDetails\n\n\n\n\nvg\nVelocityGroups\nVelocityGroups specification\n\n\nReturns\nVectorArray\n\n\n\n\nForm the right-hand side VectorArray:\n\nvec = lgs.rhs(vg)\n\nThe vector is in the \\(2\\times4\\) (velocity \\(\\times\\) density matrix) product vector space:\n\nvec.space\n\n{Atomic velocity (range)(2) ⨉ Density matrix (range)(4)}\n\n\n\nvec.space.shape\n\n(2, 4)\n\n\nWrite as a flattened 1D vector:\n\nvec.to_numpy()\n\narray([[  5e+01 ,     0   ,     0   ,     0   ,   5e+01 ,     0   ,     0   ,     0   ]])\n\n\n\ntest_array('core', 'rhs', _)\n\n\ntest_array('core', '_initial_dm', _)\n\n\nsource\n\n\nLGSSystem.stationary_model\n\n LGSSystem.stationary_model\n                             (vg:Union[int,Iterable,pylgs.velocitygroups.V\n                             elocityGroups]=6)\n\nReturn a pyMOR StationaryModel for the steady state cw LGS system.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvg\nUnion\n6\nSpecification of velocity groups\n\n\nReturns\nStationaryModel\n\nModel for the steady-state LGS system\n\n\n\nAn integer can be supplied for vg to get that many evenly spaced velocity groups:\n\nmodel = lgs.stationary_model(vg=30)\n\nSolve the model and calculate the return flux by supplying values for all free parameters:\n\nmodel.total_flux({'IntensitySI1': 1e3}).item()\n\n52423.693460667244\n\n\nSolve the model and return the steady-state density matrix:\n\nsol = model.solve({'IntensitySI1': 1e3})\n\nThe solution can be visualized in several ways. Plot the flux for each velocity bin:\n\nmodel.flux(sol).visualize()\n\n                                                \n\n\nPlot the real and imaginary parts of the density-matrix elements for each velocity bin:\n\nsol.visualize()\n\n                                                \n\n\nPlot just the level populations:\n\nmodel.level_population(sol).visualize()\n\n                                                \n\n\nPlot the total atomic population:\n\nmodel.population(sol).visualize()\n\n                                                \n\n\nNote that the above visualizations plot the contribution to the quantity from each velocity group. If the velocity groups are not all of the same width, this will cause the plots to appear distorted. In this case one can instead plot the velocity distribution of the quantities using flux_distribution, population_distribution, etc. To plot the velocity distribution of the density-matrix elements, use velocity_normalize(sol).\n\n\n\n\nTable 1: Operators that can be applied to the solution of an LGS model\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\n\n\npopulation\nFraction of total atomic population in each velocity group\n\n\ntotal_population\nTotal atomic population (should equal 1)\n\n\npopulation_distribution\nAtomic population per unit velocity interval\n\n\nlevel_population\nPopulation of each atomic level in each velocity group\n\n\ntotal_level_population\nTotal atomic population in each level\n\n\nlevel_population_distribution\nLevel population per unit velocity interval\n\n\nflux\nReturn flux on each transition from each velocity group\n\n\ntotal_flux\nTotal return flux\n\n\nflux_distribution\nReturn flux per unit velocity interval\n\n\nvelocity_sum\nSum over velocity groups\n\n\nvelocity_normalize\nNormalize by velocity-group width\n\n\n\n\n\n\n\n\nCheck that the atomic population summed over all velocity groups is approximately 1:\n\nmodel.total_population(sol).item()\n\n0.9933933945227537\n\n\n\nsource\n\n\nLGSSystem.adaptive_stationary_model\n\n LGSSystem.adaptive_stationary_model (mu, vg=6, max_weight=0.01)\n\nCreate a StationaryModel with narrower velocity bins in velocity regions with higher flux.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmu\n\n\nParameter values to use during velocity-group refinement\n\n\nvg\nint\n6\nInitial velocity groups\n\n\nmax_weight\nfloat\n0.01\nMaximum fraction of the return flux from any one velocity group\n\n\nReturns\nStationaryModel\n\nSteady-state LGS model with more velocity groups in regions that produce more return flux\n\n\n\nCreate a model with adaptively refined velocity groups using a particular value for the intensity parameter during refinement:\n\nmodel = lgs.adaptive_stationary_model({'IntensitySI1': 1e3}, max_weight=0.2)\n\nSolve and find total flux:\n\nmodel.total_flux({'IntensitySI1': 1e3}).item()\n\n91313.76877884821\n\n\nSolve for the density matrix. The solution has density-matrix values for 17 velocity groups:\n\nsol = model.solve({'IntensitySI1': 1e3})\nsol\n\n{Atomic velocity(17) ⨉ Density matrix (source)(4), }\n\n\nPlot the velocity distribution of flux. Each point marks the center of a velocity group:\n\nmodel.flux_distribution(sol).visualize(markers=True)\n\n                                                \n\n\nVelocity distribution of the density matrix:\n\nmodel.velocity_normalize(sol).visualize()\n\n                                                \n\n\nOf the total population:\n\nmodel.population_distribution(sol).visualize()\n\n                                                \n\n\nOf the level populations:\n\nmodel.level_population_distribution(sol).visualize()\n\n                                                \n\n\n\nsource\n\n\nLGSSystem.instationary_model\n\n LGSSystem.instationary_model\n                               (vg:Union[int,Iterable,pylgs.velocitygroups\n                               .VelocityGroups]=6, T=1e-06,\n                               num_values=100, initial_rho=None,\n                               time_stepper=BDFTimeStepper())\n\nCreate an InstationaryModel for the LGS system dynamics.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvg\nUnion\n6\nSpecification of velocity groups\n\n\nT\nfloat\n1e-06\nFinal time (seconds)\n\n\nnum_values\nint\n100\nNumber of time step values to return\n\n\ninitial_rho\nNoneType\nNone\nInitial density matrix. None means to use the thermal distribution\n\n\ntime_stepper\nBDFTimeStepper\nBDFTimeStepper()\nSolver to use\n\n\nReturns\nInstationaryModel\n\nModel for the LGS system dynamics\n\n\n\nAn instationary model with 30 velocity groups:\n\nmodel = lgs.instationary_model(\n    vg=30, \n    T=1.e-4, \n    num_values=20\n)\n\nThe BDF solver is efficient but can be very sensitive to the absolute and relative tolerance values. Set appropriate values for this problem:\n\npymor.basic.set_defaults({\n    'pylgs.pymor.timestepping.cvode_solver_options.cvode_bdf_atol': 1e-3,\n    'pylgs.pymor.timestepping.cvode_solver_options.cvode_bdf_rtol': 1e-5\n})\n\nSolve for a constant value of intensity:\n\nsol = model.solve({'IntensitySI1': 1e3})\n\n\n\n\nVisualize the total flux as a function of time:\n\nmodel.total_flux(sol).visualize()\n\n                                                \n\n\nPlot the density matrix elements as a function of atomic velocity and animate as a function of time:\n\nmodel.velocity_normalize(sol).visualize().update_layout(sliders=[dict(active=4)])\n\n                                                \n\n\nAnimate the population distribution as a function of time:\n\nmodel.population_distribution(sol).visualize()\n\n                                                \n\n\nAnimate the level population distributions:\n\nmodel.level_population_distribution(sol).visualize()\n\n                                                \n\n\nSet a shorter evolution time for the model:\n\nmodel = model.with_(T=.3e-7, num_values=20)\n\nSolve the model with a modulated intensity parameter:\n\nsol = model.solve({'IntensitySI1': \"5000.*sin(1.e8*t)**2\"})\n\n\n\n\nVisualize the total flux as a function of time:\n\nmodel.total_flux(sol).visualize()\n\n                                                \n\n\nVisualize the density matrix elements:\n\nmodel.velocity_normalize(sol).visualize()\n\n                                                \n\n\nVisualize the flux distribution:\n\nmodel.flux_distribution(sol).visualize()\n\n                                                \n\n\n\nmodel.population_distribution(sol).visualize()\n\n                                                \n\n\n\nsource\n\n\nLGSSystem.stationary_floquet_model\n\n LGSSystem.stationary_floquet_model (mu, T, n_vector, nu:str='nu',\n                                     n_operator=None, vg:Union[int,Iterabl\n                                     e,pylgs.velocitygroups.VelocityGroups\n                                     ]=6)\n\nReturn a StationaryFloquetModel for the Fourier coefficients of the periodic state of a modulated LGS system.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmu\n\n\nParameter specification for parameters modulated at a frequency nu\n\n\nT\n\n\nList of time values to use for reconstruction\n\n\nn_vector\n\n\nNumber of terms in the system Fourier series\n\n\nnu\nstr\nnu\nName of the frequency variable\n\n\nn_operator\nNoneType\nNone\nNumber of terms in the operator Fourier series. None defaults to n_vector - 1\n\n\nvg\nUnion\n6\nSpecification of velocity groups\n\n\nReturns\nStationaryFloquetModel\n\nModel for the Fourier coefficients of the periodic LGS system\n\n\n\nThe StationaryFloquetModel solves for the periodic state of a modulated system after the transient dynamics have died out.\nBuild a stationary Floquet model for six Fourier harmonics of a system with sinusoidally modulated intensity:\n\nmodel = lgs.stationary_floquet_model(\n    {'IntensitySI1': \"5000.*sin(nu*t)**2\"},\n    T=np.linspace(0, 1e-7, 20),\n    n_vector=3,\n    vg=30\n)\n\nDefine values for the modulation frequency and light detuning:\n\nmu = Mu(nu=1e8, DetuningHz1=0)\n\nSolve for the periodic state. The solution contains 13 Fourier coefficients for each density-matrix element in each velocity group:\n\nsol = model.solve(mu)\nsol\n\n{Fourier coefficient(7) ⨉ Atomic velocity(30) ⨉ Density matrix (source)(4), }\n\n\nThe real and imaginary parts of the Fourier coefficients of the time-dependent return flux:\n\nmodel.total_flux(sol).visualize()\n\n                                                \n\n\nThe total return flux reconstructed as a function of time:\n\nmodel.reconstructed_total_flux(sol, mu).real.visualize()\n\n                                                \n\n\nThe real and imaginary parts of the Fourier coefficients of the real and imaginary parts of the density-matrix elements:\n\nmodel.velocity_normalize(mu).visualize()\n\n                                                \n\n\nThe real and imaginary parts of the density-matrix elements reconstructed as a function of time:\n\nmodel.velocity_normalize(model.reconstruct(mu)).real.visualize()",
    "crumbs": [
      "API",
      "lgssystem"
    ]
  },
  {
    "objectID": "api/utilities/formatting.html",
    "href": "api/utilities/formatting.html",
    "title": "utilities.formatting",
    "section": "",
    "text": "source\n\nsignificant\n\n significant (x, n=1)\n\n\nsignificant(.039)\n\n0.04\n\n\n\nsource\n\n\nsignificant_digits\n\n significant_digits (x, n=1)\n\n\nsignificant(.099999, 2)\n\n0.1\n\n\n\nfor i in range(1, 5): print(significant_digits(.0999, i))\n\n1\n10\n999\n9990\n\n\n\nsignificant_digits(.099999, 2)\n\n10\n\n\n\nsignificant_digits(.039, 2)\n\n39\n\n\n\nsource\n\n\nprefix_format\n\n prefix_format (x, precision=3)\n\n\nprefix_format(1.2345678, .03)\n\n'1.23(3)'\n\n\n\nprefix_format(12.345678, .03)\n\n'0.01235(3)k'\n\n\n\nprefix_format(123.45678, .03)\n\n'0.12346(3)k'\n\n\n\nprefix_format(1234.5678, .03)\n\n'1.23457(3)k'\n\n\n\nprefix_format(1.2345678, .09)\n\n'1.23(9)'\n\n\n\nprefix_format(1.2345678, .099)\n\n'1.2(1)'\n\n\n\nprefix_format(.0012345678, .09)\n\n'(1.2±90)m'\n\n\n\nprefix_format(.0012345678, .099)\n\n'(1.2±100)m'\n\n\n\nprefix_format(.0012345678, .001)\n\n'1(1)m'\n\n\n\nprefix_format(123.45678, .099)\n\n'0.1235(1)k'\n\n\n\nprefix_format(12345.678, .09)\n\n'0.01234568(9)M'\n\n\n\nprefix_format(12345.678, .099)\n\n'0.0123457(1)M'\n\n\n\nprefix_format(12345.678, 0)\n\n'0.0M'\n\n\n\nprefix_format(12345.678, 2)\n\n'0.012M'\n\n\n\nfor i in range(-9, 10): print(prefix_format(1.2345678 * 10**i ))\n\n1.23n\n0.0123µ\n0.123µ\n1.23µ\n0.0123m\n0.123m\n1.23m\n0.0123\n0.123\n1.23\n0.0123k\n0.123k\n1.23k\n0.0123M\n0.123M\n1.23M\n0.0123G\n0.123G\n1.23G",
    "crumbs": [
      "API",
      "utilities",
      "utilities.formatting"
    ]
  },
  {
    "objectID": "api/utilities/testing.html",
    "href": "api/utilities/testing.html",
    "title": "utilities.testing",
    "section": "",
    "text": "source\n\ntest_array\n\n test_array (file, name, arr, update='allow')\n\n\nsource\n\n\ntest_da\n\n test_da (file, name, da, update='forbid')",
    "crumbs": [
      "API",
      "utilities",
      "utilities.testing"
    ]
  },
  {
    "objectID": "api/utilities/numpy.html",
    "href": "api/utilities/numpy.html",
    "title": "utilities.numpy",
    "section": "",
    "text": "source\n\nsym_range\n\n sym_range (n)\n\nA symmetric arange.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nn\n\nHalf-length of the array\n\n\nReturns\nndarray\nAn integer NumPy array running from -n to n\n\n\n\nCreate an array ranging from -2 to 2:\n\nsym_range(2)\n\narray([-2, -1,  0,  1,  2])",
    "crumbs": [
      "API",
      "utilities",
      "utilities.numpy"
    ]
  },
  {
    "objectID": "api/utilities/xarray.html",
    "href": "api/utilities/xarray.html",
    "title": "utilities.xarray",
    "section": "",
    "text": "source\n\nCoordinates.__add__\n\n Coordinates.__add__ (other)\n\nAdding two Coordinates objects combines their coordinates.\nDefine the + operator for Coordinates to combine the coordinates:\n\ncoords = Coordinates({'foo': [1, 2]}) + Coordinates({'bar': [1, 2, 3]})\ncoords\n\nCoordinates:\n  * foo      (foo) int64 16B 1 2\n  * bar      (bar) int64 24B 1 2 3\n\n\n\nsource\n\n\nCoordinates.complement\n\n Coordinates.complement (other:xarray.core.coordinates.Coordinates)\n\nReturn coordinates not in other coordinates.\n\ncoords.complement(Coordinates({'bar': [1, 2, 3]}))\n\nCoordinates:\n  * foo      (foo) int64 16B 1 2\n\n\n\nsource\n\n\nCoordinates.shape\n\n Coordinates.shape ()\n\nReturn tuple of sizes of the coordinates.\n\ncoords.shape\n\n(2, 3)\n\n\n\nsource\n\n\nCoordinates.size\n\n Coordinates.size ()\n\nReturn product of coordinate lengths.\n\ncoords.size\n\n6\n\n\n\nsource\n\n\nCoordinates.intersection\n\n Coordinates.intersection (other:xarray.core.coordinates.Coordinates)\n\nReturn coordinates in self and other.\n\ncoords.intersection(Coordinates({'foo': [1, 2]}))\n\nCoordinates:\n  * foo      (foo) int64 16B 1 2\n\n\n\nsource\n\n\nCoordinates.contain\n\n Coordinates.contain (other:xarray.core.coordinates.Coordinates)\n\nReturn true if all coordinates in other are in self, otherwise false.\n\ncoords.contain(Coordinates({'foo': [1, 2]}))\n\nTrue\n\n\n\ncoords.contain(Coordinates({'foo': [1, 2], 'baz': [4, 5]}))\n\nFalse",
    "crumbs": [
      "API",
      "utilities",
      "utilities.xarray"
    ]
  },
  {
    "objectID": "api/pymor/operators.html",
    "href": "api/pymor/operators.html",
    "title": "pymor.operators",
    "section": "",
    "text": "XarrayMatrixOperator is a replacement for NumpyMatrixOperator that affords several advantages.\n\nsource\n\n\n\n XarrayMatrixOperator (matrix:DataArray|ndarray|SparseArray|sparray,\n                       source:XarrayVectorSpace|Coordinates|dict|list|str=\n                       None, range:XarrayVectorSpace|Coordinates|dict|list\n                       |str=None, solver_options:dict=None, name:str=None)\n\nAn Operator backed by an xarray DataArray.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmatrix\nxarray.core.dataarray.DataArray | numpy.ndarray | sparse._sparse_array.SparseArray | scipy.sparse._base.sparray\n\nN-dimensional matrix\n\n\nsource\npylgs.pymor.vectorarrays.XarrayVectorSpace | xarray.core.coordinates.Coordinates | dict | list | str\nNone\nSource vector space, coordinates, or dimension name(s)\n\n\nrange\npylgs.pymor.vectorarrays.XarrayVectorSpace | xarray.core.coordinates.Coordinates | dict | list | str\nNone\nRange vector space, coordinates, or dimension name(s)\n\n\nsolver_options\ndict\nNone\nOptions for matrix solver\n\n\nname\nstr\nNone\nOperator name\n\n\n\nA pyMOR Operator maps a VectorArray from a source VectorSpace to another VectorArray in a range VectorSpace. The XarrayMatrixOperator acts on an XarrayVectorArray from an XarrayVectorSpace by means of multiplication by an xarray DataArray.\nThe html representation of an XarrayMatrixOperator is operator name{source space} → {range space}, where X is used as the name if the operator has not been given an explict name.\nThe matrix can be supplied as a DataArray, or as an unlabeled numpy ndarray, scipy.sparse sparray, or sparse SparseArray.\nCreate from a numpy array with default range and source:\n\nop = XarrayMatrixOperator(np.ones((2, 2)))\nop\n\nX{so(2)} → {ra(2)}\n\n\nThe DataArray backing the Operator is stored in the matrix attribute:\n\nop.matrix\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (range: 2, source: 2)&gt; Size: 32B\narray([[1., 1.],\n       [1., 1.]])\nDimensions without coordinates: range, sourcexarray.DataArrayrange: 2source: 21.0 1.0 1.0 1.0array([[1., 1.],\n       [1., 1.]])Coordinates: (0)Indexes: (0)Attributes: (0)\n\n\nThe source and range attributes store the corresponding VectorArrays:\n\nop.source\n\n{source(2)}\n\n\n\nop.range\n\n{range(2)}\n\n\nCreate from a numpy array with specified range and source names:\n\nXarrayMatrixOperator(array([[1, 0], [0, 1]]), source='source a', range='range a')\n\nX{SA(2)} → {RA(2)}\n\n\nCreate from a numpy array and specified range and source spaces:\n\nspace_a = XarrayVectorSpace({'A': np.linspace(0, 1, 2)})\nspace_b = XarrayVectorSpace({'B': ['c', 'd', 'e']})\nXarrayMatrixOperator(np.arange(6).reshape(2, 3), source=space_b, range=space_a, name='foo')\n\nfoo{B(3)} → {A(2)}\n\n\n\n_.matrix\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'foo' (A: 2, B: 3)&gt; Size: 48B\narray([[0, 1, 2],\n       [3, 4, 5]])\nCoordinates:\n  * A        (A) float64 16B 0.0 1.0\n  * B        (B) &lt;U1 12B 'c' 'd' 'e'xarray.DataArray'foo'A: 2B: 30 1 2 3 4 5array([[0, 1, 2],\n       [3, 4, 5]])Coordinates: (2)A(A)float640.0 1.0array([0., 1.])B(B)&lt;U1'c' 'd' 'e'array(['c', 'd', 'e'], dtype='&lt;U1')Indexes: (2)APandasIndexPandasIndex(Index([0.0, 1.0], dtype='float64', name='A'))BPandasIndexPandasIndex(Index(['c', 'd', 'e'], dtype='object', name='B'))Attributes: (0)\n\n\nCreate from a DataArray with defined coords:\n\nXarrayMatrixOperator(\n    DataArray(\n        np.arange(6).reshape(2, 3), \n        {'A': np.linspace(0, 1, 2), 'B': np.linspace(0, 1, 3)}\n    )\n)\n\nX{B(3)} → {A(2)}\n\n\nCreate from a DataArray array with default coordinate names:\n\nop = XarrayMatrixOperator(DataArray(np.ones((2, 2)), name='foo'))\nop\n\nfoo{di(2)} → {di(2)}\n\n\n\nop = XarrayMatrixOperator(sparse2d_rand([4, 5], density=.5, random_state=42))\nop\n\nX{so(5)} → {ra(4)}\n\n\n\nsource\n\n\n\n\n XarrayMatrixOperator.H ()\n\nThe adjoint operator.\n\nop.H\n\nXarrayMatrixOperator_adjoint{ra(4)} → {so(5)}\n\n\n\nsource\n\n\n\n\n XarrayMatrixOperator.apply (U, mu=None)\n\nApply the operator to an XarrayVectorArray in the source vector space.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nU\n\n\nXarrayVectorArray of vectors to which the operator is applied\n\n\nmu\nNoneType\nNone\nThe parameter values for which to evaluate the operator\n\n\nReturns\nXarrayVectorArray\n\nXarrayVectorArray in the range XarrayVectorSpace\n\n\n\n\nsource\n\n\n\n\n XarrayMatrixOperator.apply_adjoint (V, mu=None)\n\nApply the adjoint of the operator to an XarrayVectorArray in the range vector space.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nV\n\n\nXarrayVectorArray of vectors to which the operator is applied\n\n\nmu\nNoneType\nNone\nThe parameter values for which to evaluate the operator\n\n\nReturns\nXarrayVectorArray\n\nXarrayVectorArray in the source XarrayVectorSpace\n\n\n\n\nV = op.range.zeros({'len': [0]})\n\n\nop.apply_adjoint(V)\n\n{source(5), len(1)}\n\n\n\nsource\n\n\n\n\n XarrayMatrixOperator.to_numpy ()\n\nReturn the operator in dense ndarray format.\nThe returned numpy array will be of shape \\(r_1\\times \\ldots \\times r_n \\times s_1 \\times \\ldots \\times s_m\\) where \\(r_i\\) are the dimensions of the \\(n\\) vector spaces making up the range product vector space, and \\(s_j\\) are the dimensions of the \\(m\\) vector spaces making up the source product vector space.\n\nop.to_numpy()\n\narray([[7.78765841e-04, 0.00000000e+00, 7.06630522e-03, 0.00000000e+00,\n        9.73755519e-01],\n       [6.11653160e-01, 2.30624250e-02, 0.00000000e+00, 0.00000000e+00,\n        9.92211559e-01],\n       [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n        4.66656632e-02],\n       [3.99860972e-01, 0.00000000e+00, 5.24774660e-01, 6.17481510e-01,\n        0.00000000e+00]])\n\n\n\nsource\n\n\n\n\n densify\n          (obj:pymor.models.interface.Model|pymor.operators.interface.Oper\n          ator)\n\nConvert sparse operators to dense.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nobj\npymor.models.interface.Model | pymor.operators.interface.Operator\nObject to densify\n\n\nReturns\npymor.models.interface.Model | pymor.operators.interface.Operator\nDensified object\n\n\n\nAn operator backed by a sparse DataArray:\n\nop.sparse\n\nTrue\n\n\nConvert the operator to one backed by a dense DataArray:\n\ndensify(op).sparse\n\nFalse",
    "crumbs": [
      "API",
      "pymor",
      "pymor.operators"
    ]
  },
  {
    "objectID": "api/pymor/operators.html#xarraymatrixoperator",
    "href": "api/pymor/operators.html#xarraymatrixoperator",
    "title": "pymor.operators",
    "section": "",
    "text": "XarrayMatrixOperator is a replacement for NumpyMatrixOperator that affords several advantages.\n\nsource\n\n\n\n XarrayMatrixOperator (matrix:DataArray|ndarray|SparseArray|sparray,\n                       source:XarrayVectorSpace|Coordinates|dict|list|str=\n                       None, range:XarrayVectorSpace|Coordinates|dict|list\n                       |str=None, solver_options:dict=None, name:str=None)\n\nAn Operator backed by an xarray DataArray.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmatrix\nxarray.core.dataarray.DataArray | numpy.ndarray | sparse._sparse_array.SparseArray | scipy.sparse._base.sparray\n\nN-dimensional matrix\n\n\nsource\npylgs.pymor.vectorarrays.XarrayVectorSpace | xarray.core.coordinates.Coordinates | dict | list | str\nNone\nSource vector space, coordinates, or dimension name(s)\n\n\nrange\npylgs.pymor.vectorarrays.XarrayVectorSpace | xarray.core.coordinates.Coordinates | dict | list | str\nNone\nRange vector space, coordinates, or dimension name(s)\n\n\nsolver_options\ndict\nNone\nOptions for matrix solver\n\n\nname\nstr\nNone\nOperator name\n\n\n\nA pyMOR Operator maps a VectorArray from a source VectorSpace to another VectorArray in a range VectorSpace. The XarrayMatrixOperator acts on an XarrayVectorArray from an XarrayVectorSpace by means of multiplication by an xarray DataArray.\nThe html representation of an XarrayMatrixOperator is operator name{source space} → {range space}, where X is used as the name if the operator has not been given an explict name.\nThe matrix can be supplied as a DataArray, or as an unlabeled numpy ndarray, scipy.sparse sparray, or sparse SparseArray.\nCreate from a numpy array with default range and source:\n\nop = XarrayMatrixOperator(np.ones((2, 2)))\nop\n\nX{so(2)} → {ra(2)}\n\n\nThe DataArray backing the Operator is stored in the matrix attribute:\n\nop.matrix\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (range: 2, source: 2)&gt; Size: 32B\narray([[1., 1.],\n       [1., 1.]])\nDimensions without coordinates: range, sourcexarray.DataArrayrange: 2source: 21.0 1.0 1.0 1.0array([[1., 1.],\n       [1., 1.]])Coordinates: (0)Indexes: (0)Attributes: (0)\n\n\nThe source and range attributes store the corresponding VectorArrays:\n\nop.source\n\n{source(2)}\n\n\n\nop.range\n\n{range(2)}\n\n\nCreate from a numpy array with specified range and source names:\n\nXarrayMatrixOperator(array([[1, 0], [0, 1]]), source='source a', range='range a')\n\nX{SA(2)} → {RA(2)}\n\n\nCreate from a numpy array and specified range and source spaces:\n\nspace_a = XarrayVectorSpace({'A': np.linspace(0, 1, 2)})\nspace_b = XarrayVectorSpace({'B': ['c', 'd', 'e']})\nXarrayMatrixOperator(np.arange(6).reshape(2, 3), source=space_b, range=space_a, name='foo')\n\nfoo{B(3)} → {A(2)}\n\n\n\n_.matrix\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'foo' (A: 2, B: 3)&gt; Size: 48B\narray([[0, 1, 2],\n       [3, 4, 5]])\nCoordinates:\n  * A        (A) float64 16B 0.0 1.0\n  * B        (B) &lt;U1 12B 'c' 'd' 'e'xarray.DataArray'foo'A: 2B: 30 1 2 3 4 5array([[0, 1, 2],\n       [3, 4, 5]])Coordinates: (2)A(A)float640.0 1.0array([0., 1.])B(B)&lt;U1'c' 'd' 'e'array(['c', 'd', 'e'], dtype='&lt;U1')Indexes: (2)APandasIndexPandasIndex(Index([0.0, 1.0], dtype='float64', name='A'))BPandasIndexPandasIndex(Index(['c', 'd', 'e'], dtype='object', name='B'))Attributes: (0)\n\n\nCreate from a DataArray with defined coords:\n\nXarrayMatrixOperator(\n    DataArray(\n        np.arange(6).reshape(2, 3), \n        {'A': np.linspace(0, 1, 2), 'B': np.linspace(0, 1, 3)}\n    )\n)\n\nX{B(3)} → {A(2)}\n\n\nCreate from a DataArray array with default coordinate names:\n\nop = XarrayMatrixOperator(DataArray(np.ones((2, 2)), name='foo'))\nop\n\nfoo{di(2)} → {di(2)}\n\n\n\nop = XarrayMatrixOperator(sparse2d_rand([4, 5], density=.5, random_state=42))\nop\n\nX{so(5)} → {ra(4)}\n\n\n\nsource\n\n\n\n\n XarrayMatrixOperator.H ()\n\nThe adjoint operator.\n\nop.H\n\nXarrayMatrixOperator_adjoint{ra(4)} → {so(5)}\n\n\n\nsource\n\n\n\n\n XarrayMatrixOperator.apply (U, mu=None)\n\nApply the operator to an XarrayVectorArray in the source vector space.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nU\n\n\nXarrayVectorArray of vectors to which the operator is applied\n\n\nmu\nNoneType\nNone\nThe parameter values for which to evaluate the operator\n\n\nReturns\nXarrayVectorArray\n\nXarrayVectorArray in the range XarrayVectorSpace\n\n\n\n\nsource\n\n\n\n\n XarrayMatrixOperator.apply_adjoint (V, mu=None)\n\nApply the adjoint of the operator to an XarrayVectorArray in the range vector space.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nV\n\n\nXarrayVectorArray of vectors to which the operator is applied\n\n\nmu\nNoneType\nNone\nThe parameter values for which to evaluate the operator\n\n\nReturns\nXarrayVectorArray\n\nXarrayVectorArray in the source XarrayVectorSpace\n\n\n\n\nV = op.range.zeros({'len': [0]})\n\n\nop.apply_adjoint(V)\n\n{source(5), len(1)}\n\n\n\nsource\n\n\n\n\n XarrayMatrixOperator.to_numpy ()\n\nReturn the operator in dense ndarray format.\nThe returned numpy array will be of shape \\(r_1\\times \\ldots \\times r_n \\times s_1 \\times \\ldots \\times s_m\\) where \\(r_i\\) are the dimensions of the \\(n\\) vector spaces making up the range product vector space, and \\(s_j\\) are the dimensions of the \\(m\\) vector spaces making up the source product vector space.\n\nop.to_numpy()\n\narray([[7.78765841e-04, 0.00000000e+00, 7.06630522e-03, 0.00000000e+00,\n        9.73755519e-01],\n       [6.11653160e-01, 2.30624250e-02, 0.00000000e+00, 0.00000000e+00,\n        9.92211559e-01],\n       [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n        4.66656632e-02],\n       [3.99860972e-01, 0.00000000e+00, 5.24774660e-01, 6.17481510e-01,\n        0.00000000e+00]])\n\n\n\nsource\n\n\n\n\n densify\n          (obj:pymor.models.interface.Model|pymor.operators.interface.Oper\n          ator)\n\nConvert sparse operators to dense.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nobj\npymor.models.interface.Model | pymor.operators.interface.Operator\nObject to densify\n\n\nReturns\npymor.models.interface.Model | pymor.operators.interface.Operator\nDensified object\n\n\n\nAn operator backed by a sparse DataArray:\n\nop.sparse\n\nTrue\n\n\nConvert the operator to one backed by a dense DataArray:\n\ndensify(op).sparse\n\nFalse",
    "crumbs": [
      "API",
      "pymor",
      "pymor.operators"
    ]
  },
  {
    "objectID": "api/pymor/operators.html#xarrayfunctionaloperator",
    "href": "api/pymor/operators.html#xarrayfunctionaloperator",
    "title": "pymor.operators",
    "section": "XarrayFunctionalOperator",
    "text": "XarrayFunctionalOperator\n\nsource\n\nXarrayFunctionalOperator\n\n XarrayFunctionalOperator (functional:ParameterFunctional, range, source)\n\nAn Operator described by a ParameterFunctional that assembles to a XarrayMatrixOperator.",
    "crumbs": [
      "API",
      "pymor",
      "pymor.operators"
    ]
  },
  {
    "objectID": "api/pymor/operators.html#sumoperator",
    "href": "api/pymor/operators.html#sumoperator",
    "title": "pymor.operators",
    "section": "SumOperator",
    "text": "SumOperator\n\nsource\n\nSumOperator\n\n SumOperator (source_coords:Coordinates|dict, name=None)\n\nAn Operator that sums over one or more dimensions of a XarrayVectorSpace.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsource_coords\nxarray.core.coordinates.Coordinates | dict\n\nCoordinates to sum over\n\n\nname\nNoneType\nNone\nOperator name\n\n\n\n\nspace = XarrayVectorSpace({'A': [1, 2], 'B': ['a', 'b', 'c']}, name='foo')\n\n\nnp.random.seed(42)\nU = space.from_numpy(np.random.rand(space.dim))\n\n\nU.array.A\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'A' (A: 2)&gt; Size: 16B\narray([1, 2])\nCoordinates:\n  * A        (A) int64 16B 1 2xarray.DataArray'A'A: 21 2array([1, 2])Coordinates: (1)A(A)int641 2array([1, 2])Indexes: (1)APandasIndexPandasIndex(Index([1, 2], dtype='int64', name='A'))Attributes: (0)\n\n\n\nop = SumOperator(U.array.A)\nop\n\n∑{A(2)} → {1}\n\n\n\nop.source\n\n{A(2)}\n\n\n\nop.range\n\n{1}\n\n\n\nop.apply(U).array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (B: 3)&gt; Size: 24B\narray([0.9731986 , 1.10673295, 0.88798846])\nCoordinates:\n  * B        (B) &lt;U1 12B 'a' 'b' 'c'xarray.DataArrayB: 30.9732 1.107 0.888array([0.9731986 , 1.10673295, 0.88798846])Coordinates: (1)B(B)&lt;U1'a' 'b' 'c'array(['a', 'b', 'c'], dtype='&lt;U1')Indexes: (1)BPandasIndexPandasIndex(Index(['a', 'b', 'c'], dtype='object', name='B'))Attributes: (0)",
    "crumbs": [
      "API",
      "pymor",
      "pymor.operators"
    ]
  },
  {
    "objectID": "api/pymor/operators.html#scaleoperator",
    "href": "api/pymor/operators.html#scaleoperator",
    "title": "pymor.operators",
    "section": "ScaleOperator",
    "text": "ScaleOperator\n\nsource\n\nScaleOperator\n\n ScaleOperator (array, space=None, name=None)\n\nA scaling operator for XarrayVectorSpaces.\n\nspace = XarrayVectorSpace({'A': [1, 2], 'B': ['a', 'b', 'c']}, name='foo')\n\n\nU = space.from_numpy(np.arange(6))\n\n\nU.array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (A: 2, B: 3)&gt; Size: 48B\narray([[0, 1, 2],\n       [3, 4, 5]])\nCoordinates:\n  * A        (A) int64 16B 1 2\n  * B        (B) &lt;U1 12B 'a' 'b' 'c'xarray.DataArrayA: 2B: 30 1 2 3 4 5array([[0, 1, 2],\n       [3, 4, 5]])Coordinates: (2)A(A)int641 2array([1, 2])B(B)&lt;U1'a' 'b' 'c'array(['a', 'b', 'c'], dtype='&lt;U1')Indexes: (2)APandasIndexPandasIndex(Index([1, 2], dtype='int64', name='A'))BPandasIndexPandasIndex(Index(['a', 'b', 'c'], dtype='object', name='B'))Attributes: (0)\n\n\n\narr = U.array[0].drop_vars('A')\narr\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (B: 3)&gt; Size: 24B\narray([0, 1, 2])\nCoordinates:\n  * B        (B) &lt;U1 12B 'a' 'b' 'c'xarray.DataArrayB: 30 1 2array([0, 1, 2])Coordinates: (1)B(B)&lt;U1'a' 'b' 'c'array(['a', 'b', 'c'], dtype='&lt;U1')Indexes: (1)BPandasIndexPandasIndex(Index(['a', 'b', 'c'], dtype='object', name='B'))Attributes: (0)\n\n\n\nscale_op = ScaleOperator(arr, name='bar')\nscale_op\n\nbar{B(3)} → {B(3)}\n\n\n\nscale_op.apply(U)\n\n{A(2) ⨉ B(3), }\n\n\n\nspace.ones().array.data\n\narray([[1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nScaleOperator(space.ones().array.data, space=space)\n\nS{A(2) ⨉ B(3)} → {A(2) ⨉ B(3)}",
    "crumbs": [
      "API",
      "pymor",
      "pymor.operators"
    ]
  },
  {
    "objectID": "api/pymor/operators.html#lincomboperator",
    "href": "api/pymor/operators.html#lincomboperator",
    "title": "pymor.operators",
    "section": "LincombOperator",
    "text": "LincombOperator\n\nsource\n\nLincombOperator.__str__\n\n LincombOperator.__str__ ()\n\nReturn str(self).\n\n_read_sparse_dataarray('test')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'test' (dim_1: 2, another dim: 3, third dim: 4)&gt; Size: 64B\n&lt;COO: shape=(2, 3, 4), dtype=float64, nnz=2, fill_value=0.0&gt;\nCoordinates:\n  * dim_1        (dim_1) &lt;U8 64B 'A**2' 'A*sin(B)'\n  * another dim  (another dim) &lt;U3 36B 'foo' 'bar' 'baz'\n  * third dim    (third dim) &lt;U3 48B '$a$' '$b$' '$c$' '$d$'\nAttributes:\n    parameters:  ['A', 'B']xarray.DataArray'test'dim_1: 2another dim: 3third dim: 4&lt;COO: nnz=2, fill_value=0.0&gt;\n\n\n\nFormat\ncoo\n\n\nData Type\nfloat64\n\n\nShape\n(2, 3, 4)\n\n\nnnz\n2\n\n\nDensity\n0.08333333333333333\n\n\nRead-only\nTrue\n\n\nSize\n64\n\n\nStorage ratio\n0.33\n\n\n\nCoordinates: (3)dim_1(dim_1)&lt;U8'A**2' 'A*sin(B)'array(['A**2', 'A*sin(B)'], dtype='&lt;U8')another dim(another dim)&lt;U3'foo' 'bar' 'baz'array(['foo', 'bar', 'baz'], dtype='&lt;U3')third dim(third dim)&lt;U3'$a$' '$b$' '$c$' '$d$'array(['$a$', '$b$', '$c$', '$d$'], dtype='&lt;U3')Indexes: (3)dim_1PandasIndexPandasIndex(Index(['A**2', 'A*sin(B)'], dtype='object', name='dim_1'))another dimPandasIndexPandasIndex(Index(['foo', 'bar', 'baz'], dtype='object', name='another dim'))third dimPandasIndexPandasIndex(Index(['$a$', '$b$', '$c$', '$d$'], dtype='object', name='third dim'))Attributes: (1)parameters :['A', 'B']\n\n\n\nwith importlib.resources.path(\"pylgs.systems.NaD1_Toy\", \"Flux.mtxn\") as path:\n    out = _read_sparse_dataarray(path)\nout\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'Flux' (coefficients: 1, Transition: 1,\n                          Density matrix (source): 4)&gt; Size: 32B\n&lt;COO: shape=(1, 1, 4), dtype=float64, nnz=1, fill_value=0.0&gt;\nCoordinates:\n  * coefficients             (coefficients) &lt;U1 4B '1'\n  * Transition               (Transition) &lt;U33 132B '3P&lt;sub&gt;1/2&lt;/sub&gt;→3S&lt;sub&gt;...\n  * Density matrix (source)  (Density matrix (source)) &lt;U50 800B 'ρ&lt;sub&gt;Re, 3...\nAttributes:\n    parameters:  ['']xarray.DataArray'Flux'coefficients: 1Transition: 1Density matrix (source): 4&lt;COO: nnz=1, fill_value=0.0&gt;\n\n\n\nFormat\ncoo\n\n\nData Type\nfloat64\n\n\nShape\n(1, 1, 4)\n\n\nnnz\n1\n\n\nDensity\n0.25\n\n\nRead-only\nTrue\n\n\nSize\n32\n\n\nStorage ratio\n1.00\n\n\n\nCoordinates: (3)coefficients(coefficients)&lt;U1'1'array(['1'], dtype='&lt;U1')Transition(Transition)&lt;U33'3P&lt;sub&gt;1/2&lt;/sub&gt;→3S&lt;sub&gt;1/2&lt;/sub&gt;'array(['3P&lt;sub&gt;1/2&lt;/sub&gt;→3S&lt;sub&gt;1/2&lt;/sub&gt;'], dtype='&lt;U33')Density matrix (source)(Density matrix (source))&lt;U50'ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3S&lt;...array(['ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3S&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3P&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;'], dtype='&lt;U50')Indexes: (3)coefficientsPandasIndexPandasIndex(Index(['1'], dtype='object', name='coefficients'))TransitionPandasIndexPandasIndex(Index(['3P&lt;sub&gt;1/2&lt;/sub&gt;→3S&lt;sub&gt;1/2&lt;/sub&gt;'], dtype='object', name='Transition'))Density matrix (source)PandasIndexPandasIndex(Index(['ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3S&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Im, 3S&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;',\n       'ρ&lt;sub&gt;Re, 3P&lt;sub&gt;1/2&lt;/sub&gt;, 3P&lt;sub&gt;1/2&lt;/sub&gt;&lt;/sub&gt;'],\n      dtype='object', name='Density matrix (source)'))Attributes: (1)parameters :['']\n\n\n\nsource\n\n\nLincombOperator.from_file\n\n LincombOperator.from_file (file_name:str|Path, solver_options=None,\n                            name=None)\n\nRead a LincombOperator (list of sparse arrays and corresponding ExpressionParameterFunctionals) from a .mtxn file.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfile_name\nstr | Path\n\nFile name\n\n\nsolver_options\nNoneType\nNone\n\n\n\nname\nNoneType\nNone\n\n\n\n\n\nwith importlib.resources.path(\"pylgs.systems.NaD1_Toy\", \"Flux.mtxn\") as path:\n    op = LincombOperator.from_file(path)\nop\n\n[1·Flux]{DM(4)} → {Tr(1)}\n\n\n\nop.assemble()\n\nFlux{DM(4)} → {Tr(1)}\n\n\n\nop = LincombOperator.from_file('test.mtxn')\nop\n\n[f(A)·test + f(A, B)·test]{TD(4)} → {AD(3)}\n\n\n\nop.source\n\n{third dim(4)}\n\n\n\nop.range\n\n{another dim(3)}\n\n\n\nsource\n\n\nExpressionParameterFunctional.partial_evaluate\n\n ExpressionParameterFunctional.partial_evaluate\n                                                 (mu:dict|pymor.parameters\n                                                 .base.Mu)\n\nSubstitute parameter values, returning a new ExpressionParameterFunctional if expression does not evaluate to a number.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmu\ndict | pymor.parameters.base.Mu\nParameter values\n\n\nReturns\nfloat | pymor.parameters.functionals.ExpressionParameterFunctional\n\n\n\n\n\nop.coefficients[1].partial_evaluate({'A': [.5]})\n\nExpressionParameterFunctional('0.5*sin(B)', {B: 1})\n\n\n\nop.coefficients[1].partial_evaluate({'A': [.5], 'B': [2.]})\n\n0.45464871341284085\n\n\n\nsource\n\n\nLincombOperator.partial_evaluate_coefficients\n\n LincombOperator.partial_evaluate_coefficients\n                                                (mu:pymor.parameters.base.\n                                                Mu)\n\nSubstitute parameter values into linear coefficients, returning a new ExpressionParameterFunctional if expression does not evaluate to a number.\n\n\n\n\nType\nDetails\n\n\n\n\nmu\nMu\nParameter values to substitute\n\n\n\n\nop.partial_evaluate_coefficients(Mu({'A': .5}))\n\n[0.25, ExpressionParameterFunctional('0.5*sin(B)', {B: 1})]\n\n\n\nsource\n\n\nLincombOperator.partial_assemble\n\n LincombOperator.partial_assemble (mu=None)\n\nSubstitute parameter values into the linear coefficients, returning a new operator with fewer (or no) parameters.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmu\nNoneType\nNone\nParameter values to substitute\n\n\nReturns\nOperator\n\n\n\n\n\n\nop\n\n[f(A)·test + f(A, B)·test]{TD(4)} → {AD(3)}\n\n\n\nop.partial_assemble(Mu({'A': .5}))\n\n[1.0·test + f(B)·test]{TD(4)} → {AD(3)}\n\n\n\nop.partial_assemble(Mu({'A': .5, 'B': 2.}))\n\ntest{TD(4)} → {AD(3)}\n\n\n\nop.partial_assemble(Mu({'A': 0}))\n\nZeroOperator(\n    XarrayVectorSpace(\n        coords=Coordinates:\n                 * another dim  (another dim) &lt;U3 36B 'foo' 'bar' 'baz',\n        name='test'),\n    XarrayVectorSpace(\n        coords=Coordinates:\n                 * third dim  (third dim) &lt;U3 48B '$a$' '$b$' '$c$' '$d$'))\n\n\n\nsource\n\n\nLincombOperator.terms\n\n LincombOperator.terms ()\n\n\n# #| export\n# @patch\n# def scalar_part(self:LincombOperator, mu):\n#     mu_vector = Mu({k: v for k, v in mu.items() if v.size &gt; 1})\n#     return np.sum([o for o in self.terms if not set(mu_vector).intersection(o.parameters)])\n\n\n# #| export\n# @patch\n# def vector_part(self:LincombOperator, mu):\n#     mu_vector = Mu({k: v for k, v in mu.items() if v.size &gt; 1})\n#     return np.sum([o for o in self.terms if set(mu_vector).intersection(o.parameters)])",
    "crumbs": [
      "API",
      "pymor",
      "pymor.operators"
    ]
  },
  {
    "objectID": "api/pymor/operators.html#productoperator",
    "href": "api/pymor/operators.html#productoperator",
    "title": "pymor.operators",
    "section": "ProductOperator",
    "text": "ProductOperator\n\nsource\n\nProductOperator\n\n ProductOperator (operators, name=None)\n\nAn Operator given by the direct product of operators operators.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\noperators\n\n\nSequence of operators that each assemble to XarrayMatrixOperator\n\n\nname\nNoneType\nNone\nOptional name\n\n\n\n\nA = XarrayMatrixOperator(array([[1, 0], [0, 1]]), source=['source a'], range=['range a'])\nB = XarrayMatrixOperator(array([[0, 1], [1, 0]]), source=['source b'], range=['range b'])\n\n\nsource\n\n\nOperator.__mul__\n\n Operator.__mul__ (other)\n\n\nsource\n\n\nProductOperator.__str__\n\n ProductOperator.__str__ ()\n\nReturn str(self).\n\nsource\n\n\nIdentityOperator.__str__\n\n IdentityOperator.__str__ ()\n\nReturn str(self).\n\nA * IdentityOperator(B.source)\n\nX{SA(2)} → {RA(2)} ⨂ I{SB(2)} → {SB(2)}\n\n\n\nIdentityOperator(B.source) * A\n\nI{SB(2)} → {SB(2)} ⨂ X{SA(2)} → {RA(2)}\n\n\n\ndef vec(a):\n    return a.T.ravel()\n\n\ns=1\n\n\nA = XarrayMatrixOperator(\n    sparse2d_rand([3*s, 2*s], density=.1, random_state=42), \n    source='source a',\n    range='range a'\n)\nA\n\nX{SA(2)} → {RA(3)}\n\n\n\nmu = Mu(A=.5)\n\n\nB = ExpressionParameterFunctional('A**2', {'A': 1}) * XarrayMatrixOperator(\n    sparse2d_rand([4*s, 5*s], density=.1, random_state=42),\n    source='source b',\n    range='range b'\n)\nB = B.assemble(mu)\n\n\nop = A * B\nop\n\nX{SA(2)} → {RA(3)} ⨂ X{SB(5)} → {RB(4)}\n\n\n\nop.source\n\n{source a(2) ⨉ source b(5)}\n\n\n\nop.range\n\n{range a(3) ⨉ range b(4)}\n\n\n\nB.source._array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (source b: 5)&gt; Size: 40B\narray([0., 0., 0., 0., 0.])\nCoordinates:\n  * source b  (source b) int64 40B 0 1 2 3 4xarray.DataArraysource b: 50.0 0.0 0.0 0.0 0.0array([0., 0., 0., 0., 0.])Coordinates: (1)source b(source b)int640 1 2 3 4array([0, 1, 2, 3, 4])Indexes: (1)source bPandasIndexPandasIndex(RangeIndex(start=0, stop=5, step=1, name='source b'))Attributes: (0)\n\n\n\nsum_op = SumOperator(B.source._array['source b'])\n\n\nsum_op * A\n\n∑{SB(5)} → {1} ⨂ X{SA(2)} → {RA(3)}\n\n\n\nA * sum_op\n\nX{SA(2)} → {RA(3)} ⨂ ∑{SB(5)} → {1}\n\n\n\nnp.random.seed(42)\nU = op.source.from_numpy(np.random.rand(op.source._array.size))\nV = op.range.from_numpy(np.random.rand(op.range._array.size))\n\n\nU.array\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (source a: 2, source b: 5)&gt; Size: 80B\narray([[0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.15601864],\n       [0.15599452, 0.05808361, 0.86617615, 0.60111501, 0.70807258]])\nCoordinates:\n  * source a  (source a) int64 16B 0 1\n  * source b  (source b) int64 40B 0 1 2 3 4xarray.DataArraysource a: 2source b: 50.3745 0.9507 0.732 0.5987 0.156 0.156 0.05808 0.8662 0.6011 0.7081array([[0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.15601864],\n       [0.15599452, 0.05808361, 0.86617615, 0.60111501, 0.70807258]])Coordinates: (2)source a(source a)int640 1array([0, 1])source b(source b)int640 1 2 3 4array([0, 1, 2, 3, 4])Indexes: (2)source aPandasIndexPandasIndex(RangeIndex(start=0, stop=2, step=1, name='source a'))source bPandasIndexPandasIndex(RangeIndex(start=0, stop=5, step=1, name='source b'))Attributes: (0)\n\n\n\nU.space\n\n{source a(2) ⨉ source b(5)}\n\n\n\nAn = A.matrix.data\nBn = B.assemble(mu).matrix.data\nUn = U.to_numpy().T\nVn = V.to_numpy().T\n\n\nAn = A.matrix.data\nBn = B.assemble(mu).matrix.data\nBn = B.assemble(mu).matrix.data\nUn = U.to_numpy().T\nout1 = np.kron(An, Bn).dot(vec(Un))\n\nCPU times: user 111 ms, sys: 3.24 ms, total: 114 ms\nWall time: 112 ms\n\n\n\nAn = A.matrix.data\nBn = B.assemble(mu).matrix.data\nBn = B.assemble(mu).matrix.data\nUn = U.array.T.data\nout3 = An.dot(Bn.dot(Un).T).ravel()\n\nCPU times: user 381 μs, sys: 73 μs, total: 454 μs\nWall time: 416 μs\n\n\n\nout4 = A.apply(B.apply(U)).to_numpy().T\n\nCPU times: user 75.9 ms, sys: 2.05 ms, total: 77.9 ms\nWall time: 76.7 ms\n\n\n\ntest_close(out1.ravel(), out3.ravel())\ntest_close(out1.ravel(), out4.ravel())\n\n\ntest_close(\n    np.kron(An, Bn).dot(vec(Un)),\n    An.dot(Bn.dot(Un).T).ravel()\n)\n\nN.B.: to_numpy on a NumpyVectorArray effectively takes the transpose.\n\nsource\n\n\nProductOperator.apply\n\n ProductOperator.apply (U, mu=None)\n\nApply the operator to a |VectorArray|.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nU\n\n\n|VectorArray| of vectors to which the operator is applied.\n\n\nmu\nNoneType\nNone\nThe |parameter values| for which to evaluate the operator.\n\n\nReturns\n|VectorArray| of the operator evaluations.\n\n\n\n\n\n\nW = space.from_numpy(np.arange(12))\n\n\nC = ScaleOperator(W.array[0, 0].drop_vars(['A', 'len']), name='C')\nC.apply(W).name\n\n'C'\n\n\n\nD = SumOperator(W.array.A, name='D')\nD.apply(W).name\n\n'D'\n\n\n\nC = ScaleOperator(W.array[0, 0].drop_vars(['A', 'len']))\nE = (C * D)\nE.apply(W).name\n\n'D'\n\n\n\nE = C * (C * D)\nE.apply(W).array.name\n\n'D'\n\n\n\nK = A * B.assemble(mu)\nout2 = K.apply(U).to_numpy()\n\nCPU times: user 2.49 ms, sys: 108 μs, total: 2.6 ms\nWall time: 2.54 ms\n\n\n\n# test_close(out1.ravel(), out2.ravel())\n\n\ntest_close(\n    op.apply(U, mu).to_numpy().ravel(), \n    np.kron(An, Bn).dot(vec(Un))\n)\n\n\\((A\\bigotimes B)^T=A^T\\bigotimes B^T\\)\n\ntest_close(np.kron(An, Bn).T, np.kron(An.T, Bn.T))\n\n\nsource\n\n\nProductOperator.H\n\n ProductOperator.H ()\n\n\nop.H\n\nXarrayMatrixOperator_adjoint{RA(3)} → {SA(2)} ⨂ XarrayMatrixOperator_adjoint{RB(4)} → {SB(5)}\n\n\n\\(\\text{vec}(V)(A\\bigotimes B)=(A\\bigotimes B)^T\\text{vec}(V)\\).\n\nop.H.source\n\n{range a(3) ⨉ range b(4)}\n\n\n\ntest_close(\n    vec(Vn).dot(np.kron(An, Bn).todense()),\n    (np.kron(An, Bn).T).dot(vec(Vn))\n)\n\n\nsource\n\n\nProductOperator.apply_adjoint\n\n ProductOperator.apply_adjoint (V, mu=None)\n\n*Apply the adjoint operator.\nFor any given linear |Operator| op, |parameter values| mu and |VectorArrays| U, V in the :attr:~pymor.operators.interface.Operator.source resp. :attr:~pymor.operators.interface.Operator.range we have::\nop.apply_adjoint(V, mu).dot(U) == V.inner(op.apply(U, mu))\nThus, when op is represented by a matrix M, apply_adjoint is given by left-multiplication of (the complex conjugate of) M with V.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nV\n\n\n|VectorArray| of vectors to which the adjoint operator is applied.\n\n\nmu\nNoneType\nNone\nThe |parameter values| for which to apply the adjoint operator.\n\n\nReturns\n|VectorArray| of the adjoint operator evaluations.\n\n\n\n\n\n\ntest_close(\n    op.apply_adjoint(V, mu).to_numpy().ravel(),\n    vec(Vn).dot(np.kron(An, Bn).todense())\n)\n\n\nsource\n\n\nProductOperator.assemble\n\n ProductOperator.assemble (mu=None)\n\n*Assemble the operator for given |parameter values|.\nThe result of the method strongly depends on the given operator. For instance, a matrix-based operator will assemble its matrix, a |LincombOperator| will try to form the linear combination of its operators, whereas an arbitrary operator might simply return a :class:~pymor.operators.constructions.FixedParameterOperator. The only assured property of the assembled operator is that it no longer depends on a |Parameter|.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmu\nNoneType\nNone\nThe |parameter values| for which to assemble the operator.\n\n\nReturns\nParameter-independent, assembled |Operator|.\n\n\n\n\n\n\nop.assemble(mu)\n\nX{SA(2)} → {RA(3)} ⨂ X{SB(5)} → {RB(4)}\n\n\n\nzero = (0 * B).assemble()\n\n\n(A * zero).assemble()\n\nZeroOperator(\n    XarrayVectorSpace(\n        coords=Coordinates:\n                 * range a  (range a) int64 24B 0 1 2\n                 * range b  (range b) int64 32B 0 1 2 3),\n    XarrayVectorSpace(\n        coords=Coordinates:\n                 * source a  (source a) int64 16B 0 1\n                 * source b  (source b) int64 40B 0 1 2 3 4))\n\n\n\n# #| hide\n# #| exporti\n# @match_class(ProductOperator)\n# def to_matrix_ProductOperator(self, op):\n#     return self.apply(contract(op))\n    \n# ToMatrixRules.insert_rule(-2, to_matrix_ProductOperator)\n\n\n# #| hide\n# to_matrix(op, mu=mu)\n\n\nto_matrix(op, mu=mu)\n\n&lt;Compressed Sparse Row sparse array of dtype 'float64'\n    with 2 stored elements and shape (12, 10)&gt;\n\n\n\ntest_array('operators', 'to_matrix_ProductOperator_1', _.todense())\n\n\nsource\n\n\nProductOperator.as_source_array\n\n ProductOperator.as_source_array (mu=None)\n\n*Return a |VectorArray| representation of the operator in its source space.\nIn the case of a linear operator with |NumpyVectorSpace| as :attr:~pymor.operators.interface.Operator.range, this method returns for given |parameter values| mu a |VectorArray| V in the operator’s :attr:~pymor.operators.interface.Operator.source, such that ::\nself.range.make_array(V.inner(U).T) == self.apply(U, mu)\nfor all |VectorArrays| U.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmu\nNoneType\nNone\nThe |parameter values| for which to return the |VectorArray|representation.\n\n\nReturns\nV\n\nThe |VectorArray| defined above.\n\n\n\n\nop.as_source_array(mu)\n\n{source a(2) ⨉ source b(5), 1}\n\n\n\ntest_close(\n    np.kron(An, Bn).todense().ravel(),\n    op.as_source_array(mu).to_numpy().ravel()\n)\n\n\nsource\n\n\nProductOperator.as_range_array\n\n ProductOperator.as_range_array (mu=None)\n\n*Return a |VectorArray| representation of the operator in its range space.\nIn the case of a linear operator with |NumpyVectorSpace| as :attr:~pymor.operators.interface.Operator.source, this method returns for given |parameter values| mu a |VectorArray| V in the operator’s :attr:~pymor.operators.interface.Operator.range, such that ::\nV.lincomb(U.to_numpy()) == self.apply(U, mu)\nfor all |VectorArrays| U.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmu\nNoneType\nNone\nThe |parameter values| for which to return the |VectorArray|representation.\n\n\nReturns\nV\n\nThe |VectorArray| defined above.\n\n\n\n\ntest_close(\n    np.kron(An, Bn).todense().ravel(),\n    op.as_range_array(mu).to_numpy().T.ravel()\n)\n\n\nop.as_range_array(mu)\n\n{range a(3) ⨉ range b(4), 1}",
    "crumbs": [
      "API",
      "pymor",
      "pymor.operators"
    ]
  },
  {
    "objectID": "api/pymor/timestepping.html",
    "href": "api/pymor/timestepping.html",
    "title": "pymor.timestepping",
    "section": "",
    "text": "source\n\nTimeStepper.solve\n\n TimeStepper.solve (initial_time, end_time, initial_data, operator,\n                    rhs=None, mass=None, mu=None, num_values=None)\n\n*Apply time-stepper to the equation.\nThe equation is of the form ::\nM(mu) * d_t u + A(u, mu, t) = F(mu, t),\n                 u(mu, t_0) = u_0(mu).*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninitial_time\n\n\nThe time at which to begin time-stepping.\n\n\nend_time\n\n\nThe time until which to perform time-stepping.\n\n\ninitial_data\n\n\nThe solution vector at initial_timeinitial_time.\n\n\noperator\n\n\nThe |Operator| A.\n\n\nrhs\nNoneType\nNone\nThe right-hand side F (either |VectorArray| of length 1 or |Operator| withsource.dim == 1source.dim == 1). If NoneNone, zero right-hand side is assumed.\n\n\nmass\nNoneType\nNone\nThe |Operator| M. If NoneNone, the identity operator is assumed.\n\n\nmu\nNoneType\nNone\n|Parameter values| for which operatoroperator and rhsrhs are evaluated. The currenttime is added to mumu with key tt.\n\n\nnum_values\nNoneType\nNone\nThe number of returned vectors of the solution trajectory. If NoneNone, eachintermediate vector that is calculated is returned.\n\n\nReturns\n|VectorArray| containing the solution trajectory.\n\n\n\n\n\n\nsource\n\n\nAdamsTimeStepper\n\n AdamsTimeStepper ()\n\n*Interface for time-stepping algorithms.\nAlgorithms implementing this interface solve time-dependent initial value problems of the form ::\nM(mu) * d_t u + A(u, mu, t) = F(mu, t),\n                 u(mu, t_0) = u_0(mu).\nTime-steppers used by |InstationaryModel| have to fulfill this interface.*\n\nsource\n\n\nBDFTimeStepper\n\n BDFTimeStepper ()\n\n*Interface for time-stepping algorithms.\nAlgorithms implementing this interface solve time-dependent initial value problems of the form ::\nM(mu) * d_t u + A(u, mu, t) = F(mu, t),\n                 u(mu, t_0) = u_0(mu).\nTime-steppers used by |InstationaryModel| have to fulfill this interface.*\n\nfrom pymor.basic import *\n\n\np = thermal_block_problem([2,2])\nm, _ = discretize_stationary_cg(p)\npp = InstationaryProblem(p, initial_data=ConstantFunction(0., 2), T=1.)\nmm, _ = discretize_instationary_cg(pp, nt=10)\n\n\n\n\n\nsolver_options={'inverse': {'type': 'scipy_lgmres_spilu', 'preconditioner_bandwidth': 2}}\n\n\nmm = mm.with_(time_stepper=BDFTimeStepper(), num_values=200, operator=mm.operator.with_(solver_options=solver_options))\n\n\nmm.solve({'diffusion': [.5, .6, .7, .8]})\n\n\n\n\n\n\n\nNumpyVectorArray(\n    NumpyVectorSpace(20201, id='STATE'),\n    [[0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 0.00000000e+00\n      0.00000000e+00 0.00000000e+00]\n     [0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 1.67496868e-07\n      1.67496868e-07 1.65840032e-07]\n     [0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 3.34985394e-07\n      3.34985394e-07 3.30310367e-07]\n     ...\n     [0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 2.65871350e-05\n      2.59707286e-05 1.76848884e-05]\n     [0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 2.66890353e-05\n      2.60647313e-05 1.77289256e-05]\n     [0.00000000e+00 0.00000000e+00 0.00000000e+00 ... 2.67906338e-05\n      2.61583773e-05 1.77726439e-05]],\n    _len=200)\n\n\n\nsource\n\n\nStiffSwitchingTimeStepper\n\n StiffSwitchingTimeStepper ()\n\n*Interface for time-stepping algorithms.\nAlgorithms implementing this interface solve time-dependent initial value problems of the form ::\nM(mu) * d_t u + A(u, mu, t) = F(mu, t),\n                 u(mu, t_0) = u_0(mu).\nTime-steppers used by |InstationaryModel| have to fulfill this interface.*",
    "crumbs": [
      "API",
      "pymor",
      "pymor.timestepping"
    ]
  },
  {
    "objectID": "api/pymor/index.html",
    "href": "api/pymor/index.html",
    "title": "pymor",
    "section": "",
    "text": "This section contains API details for the pyMOR extensions implemented for pyLGS.\n\n\n\n\n\n\n\n\n\nTitle\n\n\nDescription\n\n\n\n\n\n\npymor.grids\n\n\nExtended functionality for pyMOR grids\n\n\n\n\npymor.models\n\n\nExtended functionality for pyMOR models\n\n\n\n\npymor.operators\n\n\nExtended functionality for pyMOR operators\n\n\n\n\npymor.parameters\n\n\nExtended functionality for pyMOR parameters\n\n\n\n\npymor.timestepping\n\n\nExtended functionality for pyMOR time steppers\n\n\n\n\npymor.vectorarrays\n\n\nExtended functionality for pyMOR vector arrays\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "API",
      "pymor"
    ]
  },
  {
    "objectID": "api/pymor/parameters.html",
    "href": "api/pymor/parameters.html",
    "title": "pymor.parameters",
    "section": "",
    "text": "source",
    "crumbs": [
      "API",
      "pymor",
      "pymor.parameters"
    ]
  },
  {
    "objectID": "api/pymor/parameters.html#simplify-functionals",
    "href": "api/pymor/parameters.html#simplify-functionals",
    "title": "pymor.parameters",
    "section": "Simplify functionals",
    "text": "Simplify functionals\n\nsource\n\nSimplifyFunctionalRules\n\n SimplifyFunctionalRules ()\n\n|RuleTable| for the :func:expand algorithm.\n\nsource\n\n\nsimplify_functionals\n\n simplify_functionals (obj)\n\n\nsimplify_functionals(functional)\n\nExpressionParameterFunctional('-3890540.14*sqrt(IntensitySI1)', {IntensitySI1: 1})",
    "crumbs": [
      "API",
      "pymor",
      "pymor.parameters"
    ]
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Click through to any of these tutorials to get started with pyLGS.\n\n\n\n\n\n\n\n\n\nTitle\n\n\nDescription\n\n\n\n\n\n\nPolychromatic LGS\n\n\nA multi-level sodium system excited by 330 nm light\n\n\n\n\nSodium LGS\n\n\nSimulate a sodium LGS beacon\n\n\n\n\nTechnical background\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Tutorials"
    ]
  },
  {
    "objectID": "tutorials/polychromatic_lgs.html",
    "href": "tutorials/polychromatic_lgs.html",
    "title": "Polychromatic LGS",
    "section": "",
    "text": "from pylgs.all import *\nDefine a LGS system pumped by 330 nm light:\nlgs = LGSSystem(\n    'Na330', \n    {\n        'IntensitySI1': 5000.,\n        'BFieldG': 0.5,\n        'EllipticityDegrees1': 45.,\n        'PolarizationAngleDegrees1': 0,\n        'DetuningHz1': 1.0832e9,\n        'LaserWidthHz1': 10.0e6,\n        'MagneticZenithDegrees': 45.,\n        'MagneticAzimuthDegrees': 45.,\n        'SDampingCollisionRatePerS': 4081.63,\n        'BeamTransitRatePerS': 131.944,\n        'VccRatePerS': 28571.,\n        'TemperatureK': 185.,\n        'RecoilParameter': 1.\n    }\n)\nThe system is made up of 774 density-matrix elements describing 7 atomic levels:\nlgs.level_population.range\n\n{Level(7) ⨉ Density matrix (source)(774)}\nHTML(', '.join(lgs.level_population.range.coords['Level'].data))\n\n3D5/2, 3S1/2, 3P1/2, 4P3/2, 4S1/2, 3D3/2, 3P3/2",
    "crumbs": [
      "Tutorials",
      "Polychromatic LGS"
    ]
  },
  {
    "objectID": "tutorials/polychromatic_lgs.html#steady-state-model",
    "href": "tutorials/polychromatic_lgs.html#steady-state-model",
    "title": "Polychromatic LGS",
    "section": "Steady-state model",
    "text": "Steady-state model\n\nAdaptively refine velocity groups\nBuild a steady-state model with adaptively refined velocity groups:\n\nmodel = lgs.adaptive_stationary_model({}, max_weight=0.02)\n\nSolve for the density matrix. There are 77 velocity groups in the model:\n\nsol = model.solve()\nsol\n\n{Atomic velocity(77) ⨉ Density matrix (source)(774), }\n\n\nPlot the total return flux for each transition as a bar chart:\n\nmodel.total_flux(sol).visualize()\n\n                                                \n\n\nPlot the flux as a function of velocity:\n\nmodel.flux_distribution(sol).visualize(xaxis_range=(-1, 2))",
    "crumbs": [
      "Tutorials",
      "Polychromatic LGS"
    ]
  },
  {
    "objectID": "tutorials/polychromatic_lgs.html#transient-dynamics-model",
    "href": "tutorials/polychromatic_lgs.html#transient-dynamics-model",
    "title": "Polychromatic LGS",
    "section": "Transient dynamics model",
    "text": "Transient dynamics model\nBuild a model for the transient dynamics:\n\nmodel = lgs.instationary_model(\n    vg=model.data['velocity_groups'], \n    T=1e-6, \n    num_values=101\n)\n\nSet tolerances for the BDF solver:\n\npymor.basic.set_defaults({\n    'pylgs.pymor.timestepping.cvode_solver_options.cvode_bdf_atol': 1e-6,\n    'pylgs.pymor.timestepping.cvode_solver_options.cvode_bdf_rtol': 1e-5,\n})\n\nSolve for the density matrix as a function of time:\n\nsol = model.solve()\n\n\n\n\nPlot the return flux for each transition:\n\nmodel.total_flux(sol).visualize()\n\n                                                \n\n\nAnimate the level population distribution as a function of time:\n\nmodel.level_population_distribution(sol).visualize(xaxis_range=(-.25, 2), yaxis_range=(0, .045))\n\n                                                \n\n\n\nlgs.Flux\n\nFlux{DM(774)} → {Tr(11)}",
    "crumbs": [
      "Tutorials",
      "Polychromatic LGS"
    ]
  }
]